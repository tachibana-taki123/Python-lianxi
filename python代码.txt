#remind:mac中python包地址:/opt/anaconda3/lib/python3.9/site-packages
#remind1:看看python正则表达式，这一块还不够熟悉
#done1:基础语法
#note1:标识符
#*第一个字符必须是字母表中字母或下划线 _ 。
#*标识符的其他的部分由字母、数字和下划线组成。
#*标识符对大小写敏感。

#note2:python保留字与关键字
import keyword
keyword.kwlist
#*保留字包括
#*'False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class',
#*'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for',
#*'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal',
#*'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'

#*关键字包括
#*end关键字
#*关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符
# Fibonacci series: 斐波纳契数列
# 两个元素的总和确定了下一个数
a, b = 0, 1
while b < 1000:
    print(b, end=',')
    a, b = b, a+b

#note3:多行语句
# *Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \ 来实现多行语句
a = 1
b = 2
c = 3
total = a + \
        b + \
        c
# !在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \
total = [a, b,
            c]

# note3:数字(Number)类型
# *python中数字有四种类型：整数、布尔型、浮点数和复数
# *int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。
# *bool (布尔), 如 True。
# *float (浮点数), 如 1.23、3E-2
# *complex (复数), 如 1 + 2j、 1.1 + 2.2j

# note4:字符串(String)
# *Python 中单引号 ' 和双引号 " 使用完全相同。
# *使用三引号(''' 或 """)可以指定一个多行字符串。
# *转义符 \。
# *反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r"this is a line with \n" 则 \n 会显示，并不是换行。
# *按字面意义级联字符串，如 "this " "is " "string" 会被自动转换为 this is string。
# *字符串可以用 + 运算符连接在一起，用 * 运算符重复。
# *Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。
# *Python 中的字符串不能改变。
# *Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。
# *字符串的截取的语法格式如下：变量[头下标:尾下标:步长]
word = '字符串'
sentence = "这是一个句子。"
paragraph = """这是一个段落，
可以由多行组成"""
# *实例
str = '123456789'
print(str)                 # *输出字符串
print(str[0:-1])           # *输出第一个到倒数第二个的所有字符
print(str[0])              # *输出字符串第一个字符
print(str[2:5])            # *输出从第三个开始到第五个的字符
print(str[2:])             # *输出从第三个开始后的所有字符
print(str[1:5:2])          # *输出从第二个开始到第五个且每隔一个的字符（步长为2）
print(str * 2)             # *输出字符串两次
print(str + '你好')         # *连接字符串
print('------------------------------')
print('hello\nrunoob')     # *使用反斜杠(\)+n转义特殊字符
print(r'hello\nrunoob')    # *在字符串前面添加一个 r，表示原始字符串，不会发生转义
# !这里的 r 指 raw，即 raw string，会自动将反斜杠转义
print('\n')       # *输出空行
print(r'\n')      # *输出 \n

# note5:空行
# *函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。
# *空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。
# *但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。
# !记住：空行也是程序代码的一部分。

# note6:等待用户输入
# *执行下面的程序在按回车键后就会等待用户输入
input("\n\n按下 enter 键后退出。")
# *\n\n 在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出

# note7:同一行显示多条语句
# *Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割
import sys; x = 'runoob'; sys.stdout.write(x + '\n')

# note8:多个语句构成代码组
# *缩进相同的一组语句构成一个代码块，我们称之代码组。
# *像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。
# *我们将首行及后面的代码组称为一个子句(clause)

# note9:print 输出
x="a"
y="b"
# *换行输出
print( x )
print( y )
print('---------')
# *不换行输出
print( x, end=" " )
print( y, end=" " )
print()
#*在输出文本中插入变量
print(f"字符串{x}")

# note9:import 与 from...import
# *在 python 用 import 或者 from...import 来导入相应的模块。
# *将整个模块(somemodule)导入，格式为： import somemodule
# *从某个模块中导入某个函数,格式为： from somemodule import somefunction
# *从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc
# *将某个模块中的全部函数导入，格式为： from somemodule import *
# *导入sys模块
import sys
print('================Python import mode==========================')
print('命令行参数为:')
for i in sys.argv:
    print(i)
print('\n python 路径为', sys.path)
# *导入 sys 模块的 argv,path 成员
from sys import argv, path  # 导入特定的成员

print('================python from import===================================')
print('path:', path)  # 因为已经导入path成员，所以此处引用时不需要加sys.path

# note10:Python3 命令行参数
# *获取命令行参数(getopt)
# *Python 中也可以所用 sys 的 sys.argv 来获取命令行参数
# *sys.argv 是命令行参数列表。
# *len(sys.argv) 计算命令行参数个数。
# !sys.argv[0] 表示脚本名
import sys

print('参数个数为:', len(sys.argv), '个参数。')
print('参数列表:', str(sys.argv))
print('脚本名:', str(sys.argv[0]))

# note11:getopt 模块
# *getopt 模块是专门处理命令行参数的模块，用于获取命令行选项和参数，也就是 sys.argv。命令行选项使得程序的参数更加灵活。支持短选项模式 - 和长选项模式 --。
# *该模块提供了两个方法及一个异常处理来解析命令行参数
# *getopt.getopt 方法用于解析命令行参数列表，语法格式如下
getopt.getopt(args, options[, long_options])
# *方法参数说明：
# *args: 要解析的命令行参数列表。
# *options: 以字符串的格式定义，options 后的冒号 : 表示该选项必须有附加的参数，不带冒号表示该选项不附加参数。
# *long_options: 以列表的格式定义，long_options 后的等号 = 表示如果设置该选项，必须有附加的参数，否则就不附加参数
# *该方法返回值由两个元素组成: 第一个是 (option, value) 元组的列表。 第二个是参数列表，包含那些没有 - 或 -- 的参数。

# *接下来我们定义一个 site() 函数，然后通过命令行输入站点名称 name 和网址 url，可以用缩写 n 和 u
import sys
import getopt
def site():
        name = None
        url = None
        argv = sys.argv[1:]
        try:
                opts, args = getopt.getopt(argv, "n:u:")  # 短选项模式
        except:
                print("Error")
        for opt, arg in opts:
                if opt in ['-n']:
                name = arg
                elif opt in ['-u']:
                url = arg
        print(name + " " + url)
site()
# *长选项模式的使用
import sys
import getopt
def site():
        name = None
        url = None
        argv = sys.argv[1:]
        try:
                opts, args = getopt.getopt(argv, "n:u:",
                                        ["name=",
                                        "url="])  # 长选项模式
        except:
                print("Error")
        for opt, arg in opts:
                if opt in ['-n', '--name']:
                name = arg
                elif opt in ['-u', '--url']:
                url = arg
        print(name + " " + url)
site()

# note12:Exception getopt.GetoptError
# *在没有找到参数列表，或选项的需要的参数为空时会触发该异常。
# *异常的参数是一个字符串，表示错误的原因。属性 msg 和 opt 为相关选项的错误信息
# *假定我们创建这样一个脚本，可以通过命令行向脚本文件传递两个文件名，同时我们通过另外一个选项查看脚本的使用。脚本使用方法如下
import sys
import getopt
def main(argv):
        inputfile = ''
        outputfile = ''
        try:
                opts, args = getopt.getopt(argv, "hi:o:", ["ifile=", "ofile="])
        except getopt.GetoptError:
                print('test.py -i <inputfile> -o <outputfile>')
                sys.exit(2)
        for opt, arg in opts:
                if opt == '-h':
                print('test.py -i <inputfile> -o <outputfile>')
                sys.exit()
                elif opt in ("-i", "--ifile"):
                inputfile = arg
                elif opt in ("-o", "--ofile"):
                outputfile = arg
        print('输入的文件为：', inputfile)
        print('输出的文件为：', outputfile)
if __name__ == "__main__":
        main(sys.argv[1:])

# done2:基本数据类型
# note13:声明
# *Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。
# *在 Python 中，变量就是变量，它没有类型，我们所说的"类型"是变量所指的内存中对象的类型。
# *等号（=）用来给变量赋值。
# *等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如
counter = 100          # 整型变量
miles = 1000.0       # 浮点型变量
name = "runoob"     # 字符串

print(counter)
print(miles)
print(name)

# note14:多变量负值
# *Python允许你同时为多个变量赋值
a = b = c = 1
# *以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。
# *也可以为多个对象指定多个变量
# *8两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 "runoob" 分配给变量 c
a, b, c = 1, 2, "runoob"

# note15:标准数据类型
# *Python3 中有六个标准的数据类型：
# *Number（数字）
# *String（字符串）
# *List（列表）
# *Tuple（元组）
# *Set（集合）
# *Dictionary（字典）
# !不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）
# !可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）

# note16:Number（数字）
# *Python3 支持 int、float、bool、complex（复数）。
# *在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。
# *像大多数语言一样，数值类型的赋值和计算都是很直观的。
# *内置的 type() 函数可以用来查询变量所指的对象类型。
a, b, c, d = 20, 5.5, True, 4+3j
print(type(a), type(b), type(c), type(d))
# !此外还可以用 isinstance 来判断
a = 111
isinstance(a, int)
# !isinstance 和 type 的区别在于:type()不会认为子类是一种父类类型,isinstance()会认为子类是一种父类类型
# !注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True==1、False==0 会返回 True，但可以通过 is 来判断类型
# !在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True
# *创建对象
var1 = 1
var2 = 10
# *也可以使用del语句删除一些对象引用，语法如下
del var1[,var2[,var3[....,varN]]]
del var
del var_a, var_b
# !注意：
# !1、Python可以同时为多个变量赋值，如a, b = 1, 2。
# !2、一个变量可以通过赋值指向不同类型的对象。
# !3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。
# !4、在混合计算时，Python会把整型转换成为浮点数。

# note17:String（字符串）
# *Python中的字符串用单引号 ' 或双引号 " 括起来，同时使用反斜杠 \ 转义特殊字符。
# *字符串的截取的语法格式如下
变量[头下标:尾下标]
# *索引值以 0 为开始值，-1 为从末尾的开始位置
# *加号 + 是字符串的连接符， 星号 * 表示复制当前字符串，与之结合的数字为复制的次数
str = 'Runoob'
print(str)              # *输出字符串
print(str[0:-1])        # *输出第一个到倒数第二个的所有字符
print(str[0])           # *输出字符串第一个字符
print(str[2:5])         # *输出从第三个开始到第五个的字符
print(str[2:])          # *输出从第三个开始的后的所有字符
print(str * 2)          # *输出字符串两次，也可以写成 print (2 * str)
print(str + "TEST")     # *连接字符串
# *Python 使用反斜杠 \ 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串
print('Ru\noob')
print(r'Ru\noob')
# *另外，反斜杠(\)可以作为续行符，表示下一行是上一行的延续。也可以使用 """...""" 或者 '''...''' 跨越多行。
# !注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串
# !与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = 'm'会导致错误
word = 'Python'
print(word[0], word[5])
print(word[-1], word[-6])
# !1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。
# !2、字符串可以用+运算符连接在一起，用*运算符重复。
# !3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。
# !4、Python中的字符串不能改变。

# note18:List（列表）
# *List（列表） 是 Python 中使用最频繁的数据类型。
# *列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。
# *列表是写在方括号 [] 之间、用逗号分隔开的元素列表。
# *和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。
# *列表截取的语法格式如下(索引值以 0 为开始值，-1 为从末尾的开始位置)
变量[头下标:尾下标]
# *加号 + 是列表连接运算符，星号 * 是重复操作。如下实例
list = ['abcd', 786, 2.23, 'runoob', 70.2]
tinylist = [123, 'runoob']
print(list)             # *输出完整列表
print(list[0])          # *输出列表第一个元素
print(list[1:3])        # *从第二个开始输出到第三个元素
print(list[2:])         # *输出从第三个元素开始的所有元素
print(tinylist * 2)     # *输出两次列表
print(list + tinylist)  # *连接列表
# !与Python字符串不一样的是，列表中的元素是可以改变的
a = [1, 2, 3, 4, 5, 6]
a[0] = 9
a[2:5] = [13, 14, 15]
a
a[2:5] = []   # *将对应的元素值设置为 []
a
# !注意：
# !1、List写在方括号之间，元素用逗号隔开。
# !2、和字符串一样，list可以被索引和切片。
# !3、List可以使用+操作符进行拼接。
# !4、List中的元素是可以改变的。
# *Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串
letters = ["r", "u", "n", "o", "o", "b"]
print(letters[1:4:2])
# *如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串
def reverseWords(input):
        # *通过空格将字符串分隔符，把各个单词分隔为列表
        inputWords = input.split(" ")
        # *翻转字符串
        # *假设列表 list = [1,2,3,4],
        # *list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)
        # *inputWords[-1::-1] 有三个参数
        # *第一个参数 -1 表示最后一个元素
        # *第二个参数为空，表示移动到列表末尾
        # *第三个参数为步长，-1 表示逆向
        inputWords = inputWords[-1::-1]
        # *重新组合字符串
        output = ' '.join(inputWords)
        return output

if __name__ == "__main__":
        input = 'I like runoob'
        rw = reverseWords(input)
        print(rw)

# note19:Tuple（元组）
# *元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。
# *元组中的元素类型也可以不相同
tuple = ('abcd', 786, 2.23, 'runoob', 70.2)
tinytuple = (123, 'runoob')

print(tuple)                    # *输出完整元组
print(tuple[0])                 # *输出元组的第一个元素
print(tuple[1:3])               # *输出从第二个元素开始到第三个元素
print(tuple[2:])                # *输出从第三个元素开始的所有元素
print(tinytuple * 2)            # *输出两次元组
print(tuple + tinytuple)        # *连接元组
# *元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。
# *其实，可以把字符串看作一种特殊的元组
tup = (1, 2, 3, 4, 5, 6)
print(tup[0])
print(tup[1:5])
# !注意：修改元组元素的操作是非法的
# !构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则
tup1 = ()    # *空元组
tup2 = (20,) # *一个元素，需要在元素后添加逗号
# !注意：
# !1、与字符串一样，元组的元素不能修改。
# !2、元组也可以被索引和切片，方法一样。
# !3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。
# !4、元组也可以使用+操作符进行拼接。

# note20:Set（集合）
# *集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。
# *基本功能是进行成员关系测试和删除重复元素。
# *可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。
# *创建格式:
parame = {value01,value02,...}
# *或者
set(value)
# *实例
sites = {'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu'}
print(sites)   # *输出集合，重复的元素被自动去掉
# 成员测试
if 'Runoob' in sites:
    print('Runoob 在集合中')
else:
    print('Runoob 不在集合中')

# set可以进行集合运算
a = set('abracadabra')
b = set('alacazam')

print(a)
print(a - b)     # *a 和 b 的差集
print(a | b)     # *a 和 b 的并集
print(a & b)     # *a 和 b 的交集
print(a ^ b)     # *a 和 b 中不同时存在的元素

# note21:Dictionary（字典）
# *字典（dictionary）是Python中另一个非常有用的内置数据类型。
# *列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。
# *字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。
# *键(key)必须使用不可变类型。
# *在同一个字典中，键(key)必须是唯一的
dict = {}
dict['one'] = "1 - 菜鸟教程"
dict[2] = "2 - 菜鸟工具"

tinydict = {'name': 'runoob', 'code': 1, 'site': 'www.runoob.com'}

print(dict['one'])        # *输出键为 'one' 的值
print(dict[2])            # *输出键为 2 的值
print(tinydict)           # *输出完整的字典
print(tinydict.keys())    # *输出所有键
print(tinydict.values())  # *输出所有值
# *构造函数 dict() 可以直接从键值对序列中构建字典如下
dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])
{x: x**2 for x in (2, 4, 6)}
dict(Runoob=1, Google=2, Taobao=3)
# !注意:
# !1、字典类型也有一些内置的函数，例如 clear()、keys()、values() 等
# !2、字典是一种映射类型，它的元素是键值对。
# !3、字典的关键字必须为不可变类型，且不能重复。
# !4、创建空字典使用 { }。

# done3:Python数据类型转换
# note22:隐式类型转换(自动完成)
# *在隐式类型转换中，Python 会自动将一种数据类型转换为另一种数据类型，不需要我们去干预。
# *以下实例中，我们对两种不同类型的数据进行运算，较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。
# *以下代码解析
# *实例中我们对两个不同数据类型的变量 num_int 和 num_flo 进行相加运算，并存储在变量 num_new 中。
# *然后查看三个变量的数据类型。
# *在输出结果中，我们看到 num_int 是 整型（integer） ， num_flo 是 浮点型（float）。
# *同样，新的变量 num_new 是 浮点型（float），这是因为 Python 会将较小的数据类型转换为较大的数据类型，以避免数据丢失。
num_int = 123
num_flo = 1.23

num_new = num_int + num_flo

print("datatype of num_int:", type(num_int))
print("datatype of num_flo:", type(num_flo))

print("Value of num_new:", num_new)
print("datatype of num_new:", type(num_new))
# *整型数据与字符串类型的数据进行相加
num_int = 123
num_str = "456"
print("Data type of num_int:",type(num_int))
print("Data type of num_str:",type(num_str))
print(num_int+num_str)
# !整型和字符串类型运算结果会报错，输出 TypeError。 Python 在这种情况下无法使用隐式转换

# note23:显式类型转换(需要使用类型函数来转换)
# *在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换
# *int() 强制转换为整型：
x = int(1)        # *x 输出结果为 1
y = int(2.8)      # *y 输出结果为 2
z = int("3")      # *z 输出结果为 3
# *float() 强制转换为浮点型：
x = float(1)      # *x 输出结果为 1.0
y = float(2.8)    # *y 输出结果为 2.8
z = float("3")    # *z 输出结果为 3.0
w = float("4.2")  # *w 输出结果为 4.2
# *str() 强制转换为字符串类型：
x = str("s1")     # *x 输出结果为 's1'
y = str(2)        # *y 输出结果为 '2'
z = str(3.0)      # *z 输出结果为 '3.0'
# *整型和字符串类型进行运算，就可以用强制类型转换来完成：
num_int = 123
num_str = "456"
print("num_int 数据类型为:", type(num_int))
print("类型转换前，num_str 数据类型为:", type(num_str))
num_str = int(num_str)    # 强制转换为整型
print("类型转换后，num_str 数据类型为:", type(num_str))
num_sum = num_int + num_str
print("num_int 与 num_str 相加结果为:", num_sum)
print("sum 数据类型为:", type(num_sum))
# *以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值
# *函数	                    描述
# *int(x [,base])          将x转换为一个整数                                    (class int(x, base=10):x -- 字符串或数字。base -- 进制数，默认十进制。返回整型数据)
# *float(x)                将x转换到一个浮点数                                  (class float([x]):x -- 整数或字符串。返回浮点数)
# *complex(real [,imag])   创建一个复数                                        (class complex([real[, imag]]):real -- int, long, float或字符串。imag -- int, long, float。返回一个复数)
# *str(x)                  将对象 x 转换为字符串                                (class str(object=''):object -- 对象。返回一个对象string)
# *repr(x)                 将对象 x 转换为表达式字符串                           (repr(object):object -- 对象。返回一个对象的 string 格式。)
# *eval(str)               用来计算在字符串中的有效Python表达式,并返回一个对象      (eval(expression[, globals[, locals]]):expression -- 表达式。globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。返回表达式计算结果。)
# *tuple(s)                将序列 s 转换为一个元组                              (tuple( iterable ):iterable -- 要转换为元组的可迭代序列。返回元组)
# *list(s)                 将序列 s 转换为一个列表                              (list( seq ):seq -- 要转换为列表的元组或字符串。返回列表。)
# *set(s)                  转换为可变集合                                      (class set([iterable]):iterable -- 可迭代对象对象。返回新的集合对象)
# *dict(d)                 创建一个字典。d 必须是一个 (key, value)元组序列        (class dict(**kwarg)/class dict(mapping, **kwarg)/class dict(iterable, **kwarg):**kwargs -- 关键字。mapping -- 元素的容器，映射类型（Mapping Types）是一种关联式的容器类型，它存储了对象与对象之间的映射关系。iterable -- 可迭代对象。返回一个字典。)
# *frozenset(s)            转换为不可变集合                                    (class frozenset([iterable]):iterable -- 可迭代的对象，比如列表、字典、元组等等。返回新的 frozenset 对象，如果不提供任何参数，默认会生成空集合。)
# *chr(x)                  将一个整数转换为一个字符                              (chr(i):i -- 可以是10进制也可以是16进制的形式的数字。返回值是当前整数对应的 ASCII 字符。)
# *ord(x)                  将一个字符转换为它的整数值                            (ord(c):c -- 字符。返回值是对应的十进制整数。)
# *hex(x)                  将一个整数转换为一个十六进制字符串                     (hex(x):x -- 10进制整数。返回16进制数，以字符串形式表示。)
# *oct(x)                  将一个整数转换为一个八进制字符串                       (oct(x):x -- 整数。返回 8 进制字符串。)

# done4:推导式
# *Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体
# note24:列表推导式
# *列表推导式子语法结构
[表达式 for 变量 in 列表]
[out_exp_res for out_exp in input_list]
# *或者
[表达式 for 变量 in 列表 if 条件]
[out_exp_res for out_exp in input_list if condition]
# *out_exp_res：列表生成元素表达式，可以是有返回值的函数。
# *for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。
# *if condition：条件语句，可以过滤列表中不符合条件的值。

# note25:字典推导式
# *字典推导基本格式
{ key_expr: value_expr for value in collection }
或
{ key_expr: value_expr for value in collection if condition }
# *使用字符串及其长度创建字典
listdemo = ['Google', 'Runoob', 'Taobao']
newdict = {key: len(key) for key in listdemo}
print(newdict)
# *提供三个数字，以三个数字为键，三个数字的平方为值来创建字典
dic = {x: x**2 for x in (2, 4, 6)}
print(dic)
type(dic)

# note26:集合推导式
# *集合推导式基本格式
{ expression for item in Sequence }
或
{ expression for item in Sequence if conditional }
# *计算数字 1,2,3 的平方数
setnew = {i**2 for i in (1,2,3)}
print(setnew)
# *判断不是 abc 的字母并输出
a = {x for x in 'abracadabra' if x not in 'abc'}
print(a)
type(a)

# note27:元组推导式（生成器表达式）
# *元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组
# *元组推导式基本格式
(expression for item in Sequence )
或
(expression for item in Sequence if conditional )
# *元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 []，另外元组推导式返回的结果是一个生成器对象
a = (x for x in range(1,10))
print(a)
# *使用 tuple() 函数，可以直接将生成器对象转换成元组
tuple(a)

# done5:Python3 注释
# note28:单行注释(#)
# *Python 中单行注释以 # 开头

# note29:多行注释('''''')
# *多行注释用三个单引号 '''

# note30:多行注释(""")
# *三个双引号 """进行注释

# done6:Python3 运算符
# note31:Python算术运算符
# *运算符	 描述	                                        实例
# *+	        加 - 两个对象相加	                         a + b 输出结果 31
# *-	        减 - 得到负数或是一个数减去另一个数	            a - b 输出结果 -11
# **	        乘 - 两个数相乘或是返回一个被重复若干次的字符串	      a * b 输出结果 210
# */	        除 - x 除以 y	                                b / a 输出结果 2.1
# *%	        取模 - 返回除法的余数	                          b % a 输出结果 1
# **(*)	        幂 - 返回x的y次幂	                         a**b 为10的21次方
# *(//)	        取整除 - 向下取接近商的整数                        9//2=4;-9//2=-5
# *实例
a = 21
b = 10
c = 0

c = a + b
print("1 - c 的值为：", c)

c = a - b
print("2 - c 的值为：", c)

c = a * b
print("3 - c 的值为：", c)

c = a / b
print("4 - c 的值为：", c)

c = a % b
print("5 - c 的值为：", c)

# 修改变量 a 、b 、c
a = 2
b = 3
c = a**b
print("6 - c 的值为：", c)

a = 10
b = 5
c = a//b
print("7 - c 的值为：", c)

# note32:Python比较运算符
# *运算符	 描述	                                                实例
# *==	        等于 - 比较对象是否相等	                                  (a == b) 返回 False。
# *(!=)	        不等于 - 比较两个对象是否不相等	                           (a != b) 返回 True。
# *>	        大于 - 返回x是否大于y	                                 (a > b) 返回 False。
# *<	        小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假   (a < b) 返回 True。
# *>=	        大于等于 - 返回x是否大于等于y。	                           (a >= b) 返回 False。
# *<=	        小于等于 - 返回x是否小于等于y。	                           (a <= b) 返回 True。
# *实例
a = 21
b = 10
c = 0

if (a == b):
    print("1 - a 等于 b")
else:
    print("1 - a 不等于 b")

if (a != b):
    print("2 - a 不等于 b")
else:
    print("2 - a 等于 b")

if (a < b):
    print("3 - a 小于 b")
else:
    print("3 - a 大于等于 b")

if (a > b):
    print("4 - a 大于 b")
else:
    print("4 - a 小于等于 b")

# 修改变量 a 和 b 的值
a = 5
b = 20
if (a <= b):
    print("5 - a 小于等于 b")
else:
    print("5 - a 大于  b")

if (b >= a):
    print("6 - b 大于等于 a")
else:
    print("6 - b 小于 a")

# note33:Python赋值运算符
# *运算符	 描述	               实例
# *(=)	        简单的赋值运算符	c = a + b 将 a + b 的运算结果赋值为 c
# *(+=)	        加法赋值运算符	        c += a 等效于 c = c + a
# *(-=)	        减法赋值运算符	        c -= a 等效于 c = c - a
# *(*=)	        乘法赋值运算符	        c *= a 等效于 c = c * a
# *(/=)	        除法赋值运算符	        c /= a 等效于 c = c / a
# *(%=)	        取模赋值运算符	        c %= a 等效于 c = c % a
# *(**=)	幂赋值运算符	        c **= a 等效于 c = c ** a
# *(//=)	取整除赋值运算符	c //= a 等效于 c = c // a
# !python3.8新增海象运算符，可在表达式内部为变量赋值。在这个示例中，赋值表达式可以避免调用 len() 两次
a = "" # *在双引号中间填入字符串
if (n := len(a)) > 10:
    print(f"List is too long ({n} elements, expected <= 10)")

"

# *实例
a = 21
b = 10
c = 0

c = a + b
print("1 - c 的值为：", c)

c += a
print("2 - c 的值为：", c)

c *= a
print("3 - c 的值为：", c)

c /= a
print("4 - c 的值为：", c)

c = 2
c %= a
print("5 - c 的值为：", c)

c **= a
print("6 - c 的值为：", c)

c //= a
print("7 - c 的值为：", c)

# note34:Python位运算符
# *按位运算符是把数字看作二进制来进行计算的
# *运算符	 描述	                                                                                实例
# *(&)	        按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0	                  (a & b) 输出结果 12 ，二进制解释： 0000 1100
# *(|)	        按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。	                                (a | b) 输出结果 61 ，二进制解释： 0011 1101
# *(^)	        按位异或运算符：当两对应的二进位相异时，结果为1	                                              (a ^ b) 输出结果 49 ，二进制解释： 0011 0001
# *(~)	        按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1	                 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。
# *(<<)	        左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。	      a << 2 输出结果 240 ，二进制解释： 1111 0000
# *(>>)	        右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数	            a >> 2 输出结果 15 ，二进制解释： 0000 1111
# *实例
a = 60            # 60 = 0011 1100
b = 13            # 13 = 0000 1101
c = 0
c = a & b        # 12 = 0000 1100
print("1 - c 的值为：", c)

c = a | b        # 61 = 0011 1101
print("2 - c 的值为：", c)

c = a ^ b        # 49 = 0011 0001
print("3 - c 的值为：", c)

c = ~a           # -61 = 1100 0011
print("4 - c 的值为：", c)

c = a << 2       # 240 = 1111 0000
print("5 - c 的值为：", c)

c = a >> 2       # 15 = 0000 1111
print("6 - c 的值为：", c)

# note35:Python逻辑运算符
# *运算符	 逻辑表达式	描述	                                                            实例
# *and	        x and y	     布尔"与" - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。	(a and b) 返回 20。
# *or	        x or y	     布尔"或" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。	         (a or b) 返回 10。
# *not	        not x	     布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。    not(a and b) 返回 False
a = 10
b = 20

if (a and b):
    print("1 - 变量 a 和 b 都为 true")
else:
    print("1 - 变量 a 和 b 有一个不为 true")

if (a or b):
    print("2 - 变量 a 和 b 都为 true，或其中一个变量为 true")
else:
    print("2 - 变量 a 和 b 都不为 true")

# *修改变量 a 的值
a = 0
if (a and b):
    print("3 - 变量 a 和 b 都为 true")
else:
    print("3 - 变量 a 和 b 有一个不为 true")

if (a or b):
    print("4 - 变量 a 和 b 都为 true，或其中一个变量为 true")
else:
    print("4 - 变量 a 和 b 都不为 true")

if not(a and b):
    print("5 - 变量 a 和 b 都为 false，或其中一个变量为 false")
else:
    print("5 - 变量 a 和 b 都为 true")

# note36:Python成员运算符
# *运算符	描述	                                           实例
# *in	       如果在指定的序列中找到值返回 True，否则返回 False。	x 在 y 序列中 , 如果 x 在 y 序列中返回 True。
# *not in      如果在指定的序列中没有找到值返回 True，否则返回 False。	 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。
# *实例
a = 10
b = 20
list = [1, 2, 3, 4, 5]

if (a in list):
    print("1 - 变量 a 在给定的列表中 list 中")
else:
    print("1 - 变量 a 不在给定的列表中 list 中")

if (b not in list):
    print("2 - 变量 b 不在给定的列表中 list 中")
else:
    print("2 - 变量 b 在给定的列表中 list 中")

# *修改变量 a 的值
a = 2
if (a in list):
    print("3 - 变量 a 在给定的列表中 list 中")
else:
    print("3 - 变量 a 不在给定的列表中 list 中")

# note37:Python身份运算符
# *身份运算符用于比较两个对象的存储单元
# *运算符	 描述	                                   实例
# *is	        is是判断两个标识符是不是引用自一个对象	        x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False
# *is not	is not 是判断两个标识符是不是引用自不同对象	x is not y ， 类似 id(x) != id(y)。如果引用的不是同一个对象则返回结果 True，否则返回 False。
a = 20
b = 20

if (a is b):
    print("1 - a 和 b 有相同的标识")
else:
    print("1 - a 和 b 没有相同的标识")

if (id(a) == id(b)):
    print("2 - a 和 b 有相同的标识")
else:
    print("2 - a 和 b 没有相同的标识")

# *修改变量 b 的值
b = 30
if (a is b):
    print("3 - a 和 b 有相同的标识")
else:
    print("3 - a 和 b 没有相同的标识")

if (a is not b):
    print("4 - a 和 b 没有相同的标识")
else:
    print("4 - a 和 b 有相同的标识")

# note38:Python运算符优先级
# *以下表格列出了从最高到最低优先级的所有运算符， 相同单元格内的运算符具有相同优先级。
# *运算符均指二元运算，除非特别指出。 相同单元格内的运算符从左至右分组（除了幂运算是从右至左分组
# *实列
a = 20
b = 10
c = 15
d = 5
e = 0

e = (a + b) * c / d  # ( 30 * 15 ) / 5
print("(a + b) * c / d 运算结果为：",  e)

e = ((a + b) * c) / d     # (30 * 15 ) / 5
print("((a + b) * c) / d 运算结果为：",  e)

e = (a + b) * (c / d)    # (30) * (15/5)
print("(a + b) * (c / d) 运算结果为：",  e)

e = a + (b * c) / d  # 20 + (150/5)
print("a + (b * c) / d 运算结果为：",  e)
# !and拥有最高优先级(例子)
x = True
y = False
z = False

if x or y and z:
    print("yes")
else:
    print("no")

"
# *以上实例先计算 y and z 并返回 False ，然后 x or False 返回 True，并在最后输出yes结果

# done7:Python3 数字(Number)
# *Python 数字数据类型用于存储数值。
# *数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。
# note39:创建数值型数据
# *以下实例在变量赋值时 Number 对象将被创建
var1 = 1
var2 = 10
# *也可以使用del语句删除一些数字对象的引用。
# *del语句的语法是
del var1[,var2[,var3[....,varN]]]
# *可以通过使用del语句删除单个或多个对象的引用
del var
del var_a, var_b

# note40:Python支持的数据类型
# *整型(int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。
# *浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）
# *复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。
# !还可以通过输入其他进制数来表示十进制数
# *16进制
number = 0xA0F
print(number)
# *8进制
number=0o37
print(number)

# note41:Python 数字类型转换
# *int(x) 将x转换为一个整数。
# *float(x) 将x转换到一个浮点数。
# *complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。
# *complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式

# note42:Python数字运算
# *Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。
# *表达式的语法很直白： +, -, * 和 /, 和其它语言（如Pascal或C）里一样
# !注意:
# !如果是除法无法整除，将会输出浮点数
# !在不同机器上浮点数运算结果可能会不一样
# *在整数除法中，除法 / 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 //
17 / 3      # *整数除法返回浮点型
17 // 3     # *整数除法返回向下取整后的结果
17 % 3      # *％操作符返回除法的余数
5 * 3 + 2
# !注意：// 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系
a = 7 // 2
b = 7.0 // 2
print("7//2结果为:", a)
print("7.0//2结果为:", b)
# *等号 = 用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何结果
width = 20
height = 5*9
width * height
900
# *Python 可以使用 ** 操作来进行幂运算
5 ** 2  # 5 的平方
2 ** 7  # 2的7次方
# !变量在使用前必须先"定义"（即赋予变量一个值），否则会出现错误(不能不负值，不像c类语言一样可以不用对变量进行负值)
# *不同类型的数混合运算时会将整数转换为浮点数
# *在交互模式中，最后被输出的表达式结果被赋值给变量 _ 。例如
tax = 12.5 / 100
price = 100.50
price * tax
price + _
round(_, 2)
# *此处， _ 变量应被用户视为只读变量

# note43:Python数学运算函数
函数	            返回值 ( 描述 )
abs(x)	            返回数字的绝对值，如abs(-10) 返回 10
ceil(x)	            返回数字的上入整数，如math.ceil(4.1) 返回 5
cmp(x, y)           如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1。 Python 3 已废弃，使用 (x>y)-(x<y) 替换。
exp(x)	            返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045
fabs(x)	            返回数字的绝对值，如math.fabs(-10) 返回10.0
floor(x)	        返回数字的下舍整数，如math.floor(4.9)返回 4
log(x)	            如math.log(math.e)返回1.0,math.log(100,10)返回2.0
log10(x)	        返回以10为基数的x的对数，如math.log10(100)返回 2.0
max(x1, x2,...)	    返回给定参数的最大值，参数可以为序列。
min(x1, x2,...)	    返回给定参数的最小值，参数可以为序列。
modf(x)	            返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。
pow(x, y)	x**y    运算后的值。
round(x [,n])	    返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。
sqrt(x)	            返回数字x的平方根。

# note44:Python随机函数
# *随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性
函数	                            描述
choice(seq)	                        从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。
randrange ([start,] stop [,step])	从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1
random()	                        随机生成下一个实数，它在[0,1)范围内。
seed([x])	                        改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。
shuffle(lst)	                    将序列的所有元素随机排序
uniform(x, y)	                    随机生成下一个实数，它在[x,y]范围内。

# note45:三角函数
函数	        描述
acos(x)	        返回x的反余弦弧度值。
asin(x)	        返回x的反正弦弧度值。
atan(x)	        返回x的反正切弧度值。
atan2(y, x)	    返回给定的 X 及 Y 坐标值的反正切值。
cos(x)	        返回x的弧度的余弦值。
hypot(x, y)	    返回欧几里德范数 sqrt(x*x + y*y)。
sin(x)	        返回的x弧度的正弦值。
tan(x)	        返回x弧度的正切值。
degrees(x)	    将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0
radians(x)	    将角度转换为弧度

# note46:数学常量
常量	 描述
pi	    数学常量 pi（圆周率，一般以π来表示）
e	    数学常量 e，e即自然常数（自然常数）。

# done8:Python字符串
# *字符串是 Python 中最常用的数据类型。我们可以使用引号( ' 或 " )来创建字符串。
# !在python中单引号，双引号不尽兴区分
# *创建字符串很简单，只要为变量分配一个值即可。例如：
var1 = 'Hello World!'
var2 = "Runoob"

# note47:Python 访问字符串中的值
# *Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。
# *Python 访问子字符串，可以使用方括号 [] 来截取字符串，字符串的截取的语法格式如下
变量[头下标:尾下标]
# !索引值以 0 为开始值，-1 为从末尾的开始位置
var1 = 'Hello World!'
var2 = "Runoob"

print("var1[0]: ", var1[0])
print("var2[1:5]: ", var2[1:5])

# note48:Python 字符串更新
# *python中支持拼接两部分的字符串，并进行输出
var1 = 'Hello World!'
print ("已更新字符串 : ", var1[:6] + 'Runoob!')

# note49:Python转义字符
转义字符	            描述
\(在行尾时)             续行符
\\                     反斜杠号
\'	                   单引号
\"	                   双引号                     "
\a	                   响铃(执行该语句后电脑会发出声音)
\b	                   退格(Backspace:在字符串中间空格)
\000	               空(在print中输入该语句后不输出任何文字)
\n	                   换行
\v	                   纵向制表符
\t	                   横向制表符
\r	                   回车，将 \r 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 \r 后面的内容完全替换完成。
\f	                   换页
\yyy	               八进制数，y 代表 0~7 的字符，例如：\012 代表换行。
\xyy	               十六进制数，以 \x 开头，y 代表的字符，例如：\x0a 代表换行
\other	               其它的字符以普通格式输出

# note50:字符串运算符
操作符	        描述	                                                          实例
+	           字符串连接	                                                      a + b 输出结果： HelloPython
*	           重复输出字符串	                                                   a*2 输出结果：HelloHello
[]	           通过索引获取字符串中字符	                                             a[1] 输出结果 e
[ : ]	       截取字符串中的一部分，遵循左闭右开原则，str[0:2] 是不包含第 3 个字符的。	   a[1:4] 输出结果 ell
in	           成员运算符 - 如果字符串中包含给定的字符返回 True	                       'H' in a 输出结果 True
not in	       成员运算符 - 如果字符串中不包含给定的字符返回 True	                   'M' not in a 输出结果 True
r/R	           原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，
               没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母     print( r'\n' ) print( R'\n' )
               r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。
%	           格式字符串
# *实例
a = "Hello"
b = "Python"

print("a + b 输出结果：", a + b)
print("a * 2 输出结果：", a * 2)
print("a[1] 输出结果：", a[1])
print("a[1:4] 输出结果：", a[1:4])

if("H" in a):
    print("H 在变量 a 中")
else:
    print("H 不在变量 a 中")

if("M" not in a):
    print("M 不在变量 a 中")
else:
    print("M 在变量 a 中")

print(r'\n')
print(R'\n')

# note51:Python字符串
# *Python 支持格式化字符串的输出 。
# *尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中
# *在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法
print ("我叫 %s 今年 %d 岁!" % ('小明', 10))
# *输出结果为:我叫 小明 今年 10 岁!

# *python字符串格式化符号
符号  描述
%c	 格式化字符及其ASCII码
%s	 格式化字符串
%d	 格式化整数
%u	 格式化无符号整型
%o	 格式化无符号八进制数
%x	 格式化无符号十六进制数
%X	 格式化无符号十六进制数（大写）
%f	 格式化浮点数字，可指定小数点后的精度
%e	 用科学计数法格式化浮点数
%E	 作用同%e，用科学计数法格式化浮点数
%g	 %f和%e的简写
%G	 %f 和 %E 的简写
%p	 用十六进制数格式化变量的地址

# *格式化操作符辅助指令
符号	功能
*	   定义宽度或者小数点精度
-	   用做左对齐
+	   在正数前面显示加号( + )
<sp>   在正数前面显示空格
#	   在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')
0	   显示的数字前面填充'0'而不是默认的空格
%	   '%%'输出一个单一的'%'
(var)  映射变量(字典参数)
m.n.   m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)

# note52:python的三引号
# *python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符
para_str = """这是一个多行字符串的实例
多行字符串可以使用制表符
TAB ( \t )。
也可以使用换行符 [ \n ]。
"""
print(para_str)

# note53:f-string
# *字面量格式化字符串，是新的格式化字符串的语法
name = 'Runoob'
print('Hello %s' % name)
# *f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去
name = 'Runoob'
f'Hello {name}'  # 替换变量
f'{1+2}'         # 使用表达式
w = {'name': 'Runoob', 'url': 'www.runoob.com'}
f'{w["name"]}: {w["url"]}'
# *用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d*

# note54:Unicode 字符串
# *在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。
# *使用的语法是在字符串前面加上前缀 u。
# *在Python3中，所有的字符串都是Unicode字符串

# note55:Python 的字符串内建函数
序号	方法及描述
1	
capitalize()
将字符串的第一个字符转换为大写
2	
center(width, fillchar)
返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。
3	
count(str, beg= 0,end=len(string))

返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数
4	
bytes.decode(encoding="utf-8", errors="strict")

Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。
5	
encode(encoding='UTF-8',errors='strict')

以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace'
6	
endswith(suffix, beg=0, end=len(string))
检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.
7	
expandtabs(tabsize=8)

把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。
8	
find(str, beg=0, end=len(string))

检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1
9	
index(str, beg=0, end=len(string))

跟find()方法一样，只不过如果str不在字符串中会报一个异常。
10	
isalnum()

如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False
11	
isalpha()

如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False
12	
isdigit()

如果字符串只包含数字则返回 True 否则返回 False..
13	
islower()

如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False
14	
isnumeric()

如果字符串中只包含数字字符，则返回 True，否则返回 False
15	
isspace()

如果字符串中只包含空白，则返回 True，否则返回 False.
16	
istitle()

如果字符串是标题化的(见 title())则返回 True，否则返回 False
17	
isupper()

如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False
18	
join(seq)

以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串
19	
len(string)

返回字符串长度
20	
ljust(width[, fillchar])

返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。
21	
lower()

转换字符串中所有大写字符为小写.
22	
lstrip()

截掉字符串左边的空格或指定字符。
23	
maketrans()

创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。
24	
max(str)

返回字符串 str 中最大的字母。
25	
min(str)

返回字符串 str 中最小的字母。
26	
replace(old, new [, max])

把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。
27	
rfind(str, beg=0,end=len(string))

类似于 find()函数，不过是从右边开始查找.
28	
rindex( str, beg=0, end=len(string))

类似于 index()，不过是从右边开始.
29	
rjust(width,[, fillchar])

返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串
30	
rstrip()

删除字符串末尾的空格或指定字符。
31	
split(str="", num=string.count(str))

以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串
32	
splitlines([keepends])

按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。
33	
startswith(substr, beg=0,end=len(string))

检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。
34	
strip([chars])

在字符串上执行 lstrip()和 rstrip()
35	
swapcase()

将字符串中大写转换为小写，小写转换为大写
36	
title()

返回"标题化"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())
37	
translate(table, deletechars="")

根据 table 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中
38
upper()

转换字符串中的小写字母为大写
39
zfill (width)

返回长度为 width 的字符串，原字符串右对齐，前面填充0
40
isdecimal()

检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。

# done9:列表
# note56:列表的介绍
# *序列是 Python 中最基本的数据结构。
# *序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。
# *Python 有 6 个序列的内置类型，但最常见的是列表和元组。
# *列表都可以进行的操作包括索引，切片，加，乘，检查成员。
# *此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。
# *列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现。
# *列表的数据项不需要具有相同的类型
# *创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：
list1 = ['Google', 'Runoob', 1997, 2000]
list2 = [1, 2, 3, 4, 5 ]
list3 = ["a", "b", "c", "d"]
list4 = ['red', 'green', 'blue', 'yellow', 'white', 'black']

# note57:访问列表中的数值
# *与字符串的索引一样，列表索引从 0 开始，第二个索引是 1，依此类推
list = ['red', 'green', 'blue', 'yellow', 'white', 'black']
print(list[0])
print(list[1])
print(list[2])
# *索引也可以从尾部开始，最后一个元素的索引为 -1，往前一位为 -2，以此类推
list = ['red', 'green', 'blue', 'yellow', 'white', 'black']
print( list[-1] )
print( list[-2] )
print( list[-3] )
# *使用下标索引来访问列表中的值，同样你也可以使用方括号 [] 的形式截取字符
nums = [10, 20, 30, 40, 50, 60, 70, 80, 90]
print(nums[0:4]) #*从第一个数字到最后一个数字
# *使用负数索引值截取
list = ['Google', 'Runoob', "Zhihu", "Taobao", "Wiki"]
# 读取第二位
print ("list[1]: ", list[1])
# 从第二位开始（包含）截取到倒数第二位（不包含）
print ("list[1:-2]: ", list[1:-2])

# note58:更新列表
# *可以对列表的数据项进行修改或更新，你也可以使用 append() 方法来添加列表项
list = ['Google', 'Runoob', 1997, 2000]

print ("第三个元素为 : ", list[2])
list[2] = 2001
print ("更新后的第三个元素为 : ", list[2])

list1 = ['Google', 'Runoob', 'Taobao']
list1.append('Baidu')
print ("更新后的列表 : ", list1)

# note59:删除列表元素
# *可以使用del对列表中的元素进行删除
list = ['Google', 'Runoob', 1997, 2000]
print ("原始列表 : ", list)
del list[2]
print ("删除第三个元素 : ", list)

# note60:Python列表脚本操作符
Python 表达式	                            结果	                        描述
len([1, 2, 3])	                           3	                           长度
[1, 2, 3] + [4, 5, 6]	                   [1, 2, 3, 4, 5, 6]	           组合
['Hi!'] * 4	                               ['Hi!', 'Hi!', 'Hi!', 'Hi!']	   重复
3 in [1, 2, 3]	                           True	                           元素是否存在于列表中
for x in [1, 2, 3]: print(x, end=" ")	   1 2 3	                       迭代

# note61:Python列表截取与拼接
L=['Google', 'Runoob', 'Taobao']
Python表达式	 结果	                描述
L[2]	        'Taobao'	          读取第三个元素
L[-2]	        'Runoob'	          从右侧开始读取倒数第二个元素: count from the right
L[1:]	        ['Runoob', 'Taobao']  输出从第二个元素开始后的所有元素
# *同时还支持拼接操作
squares = [1, 4, 9, 16, 25]
squares += [36, 49, 64, 81, 100]
print(squares)

# note62:嵌套列表
# *使用嵌套列表即在列表里创建其它列表
a = ['a', 'b', 'c']
n = [1, 2, 3]
x = [a, n]
x
x[0]
['a', 'b', 'c']
x[0][1]

# note63:列表比较
# *列表比较需要引入 operator 模块的 eq 方法
import operator
a = [1, 2]
b = [2, 3]
c = [2, 3]
print("operator.eq(a,b): ", operator.eq(a,b))
print("operator.eq(c,b): ", operator.eq(c,b))

"

# note63:列表函数
序号	函数
1	   len(list)
       列表元素个数
2	   max(list)
       返回列表元素最大值
3	   min(list)
       返回列表元素最小值
4	   list(seq)
       将元组转换为列表

# note63:列表方法
序号	方法
1	list.append(obj)
在列表末尾添加新的对象
2	list.count(obj)
统计某个元素在列表中出现的次数
3	list.extend(seq)
在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
4	list.index(obj)
从列表中找出某个值第一个匹配项的索引位置
5	list.insert(index, obj)
将对象插入列表
6	list.pop([index=-1])
移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
7	list.remove(obj)
移除列表中某个值的第一个匹配项
8	list.reverse()
反向列表中元素
9	list.sort( key=None, reverse=False)
对原列表进行排序
10	list.clear()
清空列表
11	list.copy()
复制列表

# done10:python元组
# note64:元组介绍
#*Python 的元组与列表类似，不同之处在于元组的元素不能修改。
#*元组使用小括号 ( )，列表使用方括号 [ ]。
#*元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。

#*创建空元组
tup1 = ()
#*实例
tup1 = ('Google', 'Runoob', 1997, 2000)
tup2 = (1, 2, 3, 4, 5 )
tup3 = "a", "b", "c", "d"   #  不需要括号也可以
print(tup3)
type(tup3)
#*元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用
tup1 = (50)
print(tup1)
type(tup1)     # 不加逗号，类型为整型
tup2 = (50,)
print(tup2)
type(tup2)     # 加上逗号，类型为元组

# note65:访问元组
# *元组可以使用下标索引来访问元组中的值
tup1 = ('Google', 'Runoob', 1997, 2000)
tup2 = (1, 2, 3, 4, 5, 6, 7 )
print ("tup1[0]: ", tup1[0])
print ("tup2[1:5]: ", tup2[1:5])

# note66:修改元组
# *元组中的元素值是不允许修改的，但我们可以对元组进行连接组合
tup1 = (12, 34.56)
tup2 = ('abc', 'xyz')
# 以下修改元组元素操作是非法的。
# tup1[0] = 100
# 创建一个新的元组
tup3 = tup1 + tup2
print (tup3)

# note67:删除元组
#*元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组
#!注意:使用del会删除整个元组,小心使用del操作
tup = ('Google', 'Runoob', 1997, 2000)
print (tup)
del tup
print ("删除后的元组 tup : ")
print (tup)

# note68:元组运算符
#*与字符串一样，元组之间可以使用 + 号和 * 号进行运算。
#*这就意味着他们可以组合和复制，运算后会生成一个新的元组

# note69:元组索引，截取
#*因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素
tup = ('Google', 'Runoob', 'Taobao', 'Wiki', 'Weibo','Weixin')
Python 表达式	    结果	                                            描述
tup[1]	           'Runoob'	                                          读取第二个元素
tup[-2]	           'Weibo'	                                          反向读取，读取倒数第二个元素
tup[1:]	           ('Runoob', 'Taobao', 'Wiki', 'Weibo', 'Weixin')	  截取元素，从第二个开始后的所有元素。
tup[1:4]	       ('Runoob', 'Taobao', 'Wiki')	                      截取元素，从第二个开始到第四个元素（索引为 3）

# note70:元组中的内置函数
1	len(tuple)
#*计算元组元素个数。
>>> tuple1 = ('Google', 'Runoob', 'Taobao')
>>> len(tuple1)
3
>>>
2	max(tuple)
#*返回元组中元素最大值。
>>> tuple2 = ('5', '4', '8')
>>> max(tuple2)
'8'
>>>
3	min(tuple)
#*返回元组中元素最小值。
>>> tuple2 = ('5', '4', '8')
>>> min(tuple2)
'4'
>>>
4	tuple(iterable)
#*将可迭代系列转换为元组。
>>> list1= ['Google', 'Taobao', 'Runoob', 'Baidu']
>>> tuple1=tuple(list1)
>>> tuple1
('Google', 'Taobao', 'Runoob', 'Baidu')

#!所谓元组的不可变指的是元组所指向的内存中的内容不可变
#!运行以下代码会出现报错:不支持修改元素
tup = ('r', 'u', 'n', 'o', 'o', 'b')
tup[0] = 'g'     # 不支持修改元素
id(tup)     # 查看内存地址
tup = (1,2,3)
id(tup)

# done11:python字典
# note71:字典介绍
#*字典是另一种可变容器模型，且可存储任意类型对象。
#*字典的每个键值 key=>value 对用冒号 : 分割
#*每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示
d = {key1 : value1, key2 : value2, key3 : value3 }
#!注意：dict 作为 Python 的关键字和内置函数，变量名不建议命名为 dict
#*键必须是唯一的，但值则不必。
#*值可以取任何数据类型，但键必须是不可变的，如字符串，数字
tinydict1 = { 'abc': 456 }
tinydict2 = { 'abc': 123, 98.6: 37 }

# note72:创建一个空字典
#*使用一个{}创建一个新字典
# 使用大括号 {} 来创建空字典
emptyDict = {}
# 打印字典
print(emptyDict)
# 查看的数量
print("Length:", len(emptyDict))
# 查看类型
print(type(emptyDict))
#*使用内建函数 dict() 创建字典
emptyDict = dict()
# 打印字典
print(emptyDict)
# 查看字典的数量
print("Length:",len(emptyDict))
# 查看类型
print(type(emptyDict))

# note73:访问字典中的数值
#*把相应的键放入到方括号中
tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
print ("tinydict['Name']: ", tinydict['Name'])
print ("tinydict['Age']: ", tinydict['Age'])
#!如果用字典里没有的键访问数据，代码将无法运行下去

# note74:修改字典
#*向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例
tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
tinydict['Age'] = 8               # 更新 Age
tinydict['School'] = "教程"  # 添加信息
print ("tinydict['Age']: ", tinydict['Age'])
print ("tinydict['School']: ", tinydict['School'])

# note75:删除字典
#*能删单一的元素也能清空字典，清空只需一项操作。显式删除一个字典用del命令
tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
del tinydict['Name'] # 删除键 'Name'
tinydict.clear()     # 清空字典
del tinydict         # 删除字典
print ("tinydict['Age']: ", tinydict['Age'])
print ("tinydict['School']: ", tinydict['School'])
#!代码无法进行，因为已经通过del函数将字典删除

# note76:字典健的特性
#!不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住
tinydict = {'Name': 'Runoob', 'Age': 7, 'Name': '小菜鸟'}
print ("tinydict['Name']: ", tinydict['Name'])
#!键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行
tinydict = {['Name']: 'Runoob', 'Age': 7}
print ("tinydict['Name']: ", tinydict['Name'])

# note77:字典内置函数以及使用方法
#*python字典中包含以下内置函数
#*1	len(dict)
#*计算字典元素个数，即键的总数。
tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
len(tinydict)
3
#*2	str(dict)
#*输出字典，可以打印的字符串表示。
tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
str(tinydict)
"{'Name': 'Runoob', 'Class': 'First', 'Age': 7}"
#*3	type(variable)
#*返回输入的变量类型，如果变量是字典就返回字典类型。
tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
type(tinydict)
<class 'dict'>

#*python字典中包含以下内置方法
序号	函数及描述
1	dict.clear()
删除字典内所有元素
2	dict.copy()
返回一个字典的浅复制
3	dict.fromkeys()
创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值
4	dict.get(key, default=None)
返回指定键的值，如果键不在字典中返回 default 设置的默认值
5	key in dict
如果键在字典dict里返回true，否则返回false
6	dict.items()
以列表返回一个视图对象
7	dict.keys()
返回一个视图对象
8	dict.setdefault(key, default=None)
和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default
9	dict.update(dict2)
把字典dict2的键/值对更新到dict里
10	dict.values()
返回一个视图对象
11	pop(key[,default])
删除字典 key（键）所对应的值，返回被删除的值。
12	popitem()
返回并删除字典中的最后一对键和值。

# done12:python集合
# note78:python集合介绍
#*集合（set）是一个无序的不重复元素序列。
#*可以使用大括号 { } 或者 set() 函数创建集合
#!注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。
#*创建格式:
parame = {value01,value02,...}
或者
set(value)
#*实际案例
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)                      # *这里演示的是去重功能
'orange' in basket                 # *快速判断元素是否在集合内
'crabgrass' in basket
# *下面展示两个集合间的运算.
a = set('abracadabra')
b = set('alacazam')
a
a - b                              # *集合a中包含而集合b中不包含的元素
a | b                              # *集合a或b中包含的所有元素
a & b                              # *集合a和b中都包含了的元素
a ^ b                              # *不同时包含于a和b的元素

#*类似列表推导式，同样集合支持集合推导式(Set comprehension):
a = {x for x in 'abracadabra' if x not in 'abc'}
a

# note79:集合的基本操作

#*向集合中添加元素
#*语法格式如下
s.add( x )
#*将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作
thisset = set(("Google", "Runoob", "Taobao"))
thisset.add("Facebook")
print(thisset)
#*还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下
s.update( x )
#!x 可以有多个，用逗号分开
thisset = set(("Google", "Runoob", "Taobao"))
thisset.update({1,3})
print(thisset)
thisset.update([1,4],[5,6])
print(thisset)

#*移除元素
#*语法格式如下
s.remove( x )
#*将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误
#!一下代码无法运行，因为集合中的元素已经被删除
thisset = set(("Google", "Runoob", "Taobao"))
thisset.remove("Taobao")
print(thisset)
thisset.remove("Facebook")   # 不存在会发生错误
#*此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示：
s.discard( x )
#*实际案例
thisset = set(("Google", "Runoob", "Taobao"))
thisset.discard("Facebook")  # 不存在不会发生错误
print(thisset)
#*我们也可以设置随机删除集合中的一个元素，语法格式如下：
s.pop()
#*实际案列
thisset = set(("Google", "Runoob", "Taobao", "Facebook"))
x = thisset.pop()
print(x)
#*set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除

#*计算集合中所含元素个数
#*语法格式如下:
len(s)
#*计算集合thisset中元素个数
thisset = set(("Google", "Runoob", "Taobao"))
len(thisset)

#*清空集合中所有元素
#*语法如下:
s.clear()
#*实际案列
thisset = set(("Google", "Runoob", "Taobao"))
thisset.clear()
print(thisset)

#*判断元素在集合中是否存在
#*语法如下:
x in s
#*如果在集合中存在该元素则返回true，如果集合中不存在该元素就返回false
#*实际案列
thisset = set(("Google", "Runoob", "Taobao"))
"Runoob" in thisset
"Facebook" in thisset

# note80:集合内置方法完整列表
方法	                        描述
add()	                       为集合添加元素
clear()	                       移除集合中的所有元素
copy()	                       拷贝一个集合
difference()	               返回多个集合的差集
difference_update()	           移除集合中的元素，该元素在指定的集合也存在。
discard()	                   删除集合中指定的元素
intersection()	               返回集合的交集
intersection_update()	       返回集合的交集。
isdisjoint()	               判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。
issubset()	                   判断指定集合是否为该方法参数集合的子集。
issuperset()	               判断该方法的参数集合是否为指定集合的子集
pop()	                       随机移除元素
remove()	                   移除指定元素
symmetric_difference()	       返回两个集合中不重复的元素集合。
symmetric_difference_update()  移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。
union()	                       返回两个集合的并集
update()	                   给集合添加元素

# done13:条件控制语句
#*Python 条件语句是通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块
# note81:if语句
#*Python中if语句的一般形式如下所示
if condition_1:
    statement_block_1
elif condition_2:
    statement_block_2
else:
    statement_block_3
#*如果 "condition_1" 为 True 将执行 "statement_block_1" 块语句
#*如果 "condition_1" 为False，将判断 "condition_2"
#*如果"condition_2" 为 True 将执行 "statement_block_2" 块语句
#*如果 "condition_2" 为False，将执行"statement_block_3"块语句
#!1、Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else
#!2、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。
#!3、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。
#!4、在Python中没有switch – case语句。
#*实际案列1
var1 = 100
if var1:
    print ("1 - if 表达式条件为 true")
    print (var1)
var2 = 0
if var2:
    print ("2 - if 表达式条件为 true")
    print (var2)
print ("Good bye!")
#*结果可以看到由于变量 var2 为 0，所以对应的 if 内的语句没有执行

#*实际案例2(勾勾年龄判断)
age = int(input("请输入你家狗狗的年龄: "))
print("")
if age <= 0:
    print("年龄数值输入错误!")
elif age == 1:
    print("相当于 14 岁的人。")
elif age == 2:
    print("相当于 22 岁的人。")
elif age > 2:
    human = 22 + (age -2)*5
    print("对应人类年龄: ", human)
### 退出提示
input("点击 enter 键退出")

#*以下为if中常用的操作运算符
操作符	描述
<	   小于
<=	   小于或等于
>	   大于
>=	   大于或等于
==	   等于，比较两个值是否相等
!=	   不等于
#*实际案例(运算符展示)
# 程序演示了 == 操作符
# 使用数字(输出false)
print(5 == 6)
# 使用变量
x = 5
y = 8
print(x == y)
#*其他比较运算符实例
# 该实例演示了数字猜谜游戏
number = 7
guess = -1
print("数字猜谜游戏!")
while guess != number:
    guess = int(input("请输入你猜的数字："))
    if guess == number:
        print("恭喜，你猜对了！")
        input("点击 enter 键退出")
    elif guess < number:
        print("猜的数字小了...")
    elif guess > number:
        print("猜的数字大了...")

# note82:if嵌套语句
#*在嵌套 if 语句中，可以把 if...elif...else 结构放在另外一个 if...elif...else 结构中
if 表达式1:
    语句
    if 表达式2:
        语句
    elif 表达式3:
        语句
    else:
        语句
elif 表达式4:
    语句
else:
    语句

#*实际案例
num=int(input("输入一个数字："))
if num%2==0:
    if num%3==0:
        print ("你输入的数字可以整除 2 和 3")
    else:
        print ("你输入的数字可以整除 2，但不能整除 3")
else:
    if num%3==0:
        print ("你输入的数字可以整除 3，但不能整除 2")
    else:
        print  ("你输入的数字不能整除 2 和 3")

# done14:循环语句
#*Python 中的循环语句有 for 和 while
# note83:while循环语句
#*Python 中 while 语句的一般形式：
while 判断条件(condition)：
    执行语句(statements)……
#!注意冒号和缩进。另外，在 Python 中没有 do..while 循环
#*以下实例使用了 while 来计算 1 到 100 的总和
n = 100
sum = 0
counter = 1
while counter <= n:
    sum = sum + counter
    counter += 1
print("1 到 %d 之和为: %d" % (n,sum))

# note84:无限循环
#*可以通过设置条件表达式永远不为 false 来实现无限循环
var = 1
while var == 1 :  # 表达式永远为 true
    num = int(input("输入一个数字  :"))
    print ("你输入的数字是: ", num)
print ("Good bye!")
#!使用 CTRL+C 来退出当前的无限循环

# note85:while循环使用else语句
#*如果 while 后面的条件语句为 false 时，则执行 else 的语句块。
#*语法格式如下：
while <expr>:
    <statement(s)>
else:
    <additional_statement(s)>
#*expr 条件语句为 true 则执行 statement(s) 语句块，如果为 false，则执行 additional_statement(s)。
#*循环输出数字，并判断大小：
count = 0
while count < 5:
    print (count, " 小于 5")
    count = count + 1
else:
    print (count, " 大于或等于 5")

# note86:简单语句组
#*类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示
flag = 1
while (flag): print ('欢迎访问!')
print ("Good bye!")
#!注意：以上的无限循环你可以使用 CTRL+C 来中断循环

# note87:for语句
#*Python for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。
#*for循环的一般格式如下：
for <variable> in <sequence>:
    <statements>
else:
    <statements>
#*以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体：
sites = ["Baidu", "Google","Runoob","Taobao"]
for site in sites:
    if site == "Runoob":
        print("教程!")
        break
    print("循环数据 " + site)
else:
    print("没有循环数据!")
print("完成循环!")

# note88:range()函数
for i in range(5):
    print(i)
#*也可以使用range指定区间的值
for i in range(5,9) :
    print(i)
#*也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做'步长')
#*参数依次为(输出的第一个数字,截止范围,取数间隔)
for i in range(0, 10, 3) :
    print(i)
#*可以结合range()和len()函数以遍历一个序列的索引,如下所示
a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ']
for i in range(len(a)):
    print(i, a[i])
#*还可以使用range()函数来创建一个列表
list(range(5))

# note89:break 和 continue 语句及循环中的 else 子句
#*break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。
#*continue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环
#*while中使用break中断
n = 5
while n > 0:
    n -= 1
    if n == 2:
        break
    print(n)
print('循环结束。')
#*while中使用continue
n = 5
while n > 0:
    n -= 1
    if n == 2:
        continue
    print(n)
print('循环结束。')

#*其他实例
for letter in 'Runoob':     # 第一个实例
    if letter == 'b':
        break
    print ('当前字母为 :', letter)
var = 10                    # 第二个实例
while var > 0:
    print ('当前变量值为 :', var)
    var = var -1
    if var == 5:
        break
print ("Good bye!")
#*以下实例循环字符串 Runoob，碰到字母 o 跳过输出
for letter in 'Runoob':     # 第一个实例
    if letter == 'o':        # 字母为 o 时跳过输出
        continue
    print ('当前字母 :', letter)
var = 10                    # 第二个实例
while var > 0:
    var = var -1
    if var == 5:             # 变量为 5 时跳过输出
        continue
    print ('当前变量值 :', var)
print ("Good bye!")
#*循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。
#*如下实例用于查询质数的循环例子
a = int(input("请输入您想检验到的数字范围:"))
for n in range(2, a):
    for x in range(2, n):
        if n % x == 0:
            print(n, '等于', x, '*', n//x)
            break
    else:
        # 循环中没有找到元素
        print(n, ' 是质数')

# note90:pass语句
#*Python pass是空语句，是为了保持程序结构的完整性。
#*pass 不做任何事情，一般用做占位语句，如下实例
while True:
    pass  # 等待键盘中断 (Ctrl+C)
#*最小的类
class MyEmptyClass:
    pass
#*以下实例在遇到字母o的时候，执行包含pass的语句
for letter in 'Runoob':
    if letter == 'o':
        pass
        print ('执行 pass 块')
    print ('当前字母 :', letter)
print ("Good bye!")

# done15:迭代器与生成器
# note91:迭代器
#*迭代是Python最强大的功能之一，是访问集合元素的一种方式。
#*迭代器是一个可以记住遍历的位置的对象。
#*迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
#*迭代器有两个基本的方法：iter() 和 next()。
#*字符串，列表或元组对象都可用于创建迭代器：
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
print (next(it))   # 输出迭代器的下一个元素
print (next(it))
#*迭代器对象可以使用常规for语句进行遍历
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
for x in it:
    print (x, end=" ")
#*也可以使用next函数
import sys         # 引入 sys 模块
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
#!使用jupyter窗口运行时出现报错，但是使用终端可以正常运行

# note92:创建一个迭代器
#*把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。
#*如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 __init__(), 它会在对象初始化的时候执行
#*__iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。
#*__next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。
#*创建一个返回数字的迭代器，初始值为 1，逐步递增 1：
class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self
    def __next__(self):
        x = self.a
        self.a += 1
        return x
myclass = MyNumbers()
myiter = iter(myclass)
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))

# note93:StopIteration
#*StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。
class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        if self.a <= 20:
            x = self.a
            self.a += 1
        else:
            raise StopIteration
        return x


myclass = MyNumbers()
myiter = iter(myclass)
for x in myiter:
    print(x)

# note94:生成器
#*在 Python 中，使用了 yield 的函数被称为生成器（generator）。
#*跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。
#*在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。
#*调用一个生成器函数，返回的是一个迭代器对象。
#*以下实例使用 yield 实现斐波那契数列：
import sys


def fibonacci(n):  # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter > n):
            return
        yield a
        a, b = b, a + b
        counter += 1


f = fibonacci(10)  # f 是一个迭代器，由生成器返回生成

while True:
    try:
        print(next(f), end=" ")
    except StopIteration:
        sys.exit()

# done16:Python函数
#*函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。
#*函数能提高应用的模块性，和代码的重复利用率。
#*Python提供了许多内建函数，比如print()。
#*但你也可以自己创建函数，这被叫做用户自定义函数
# note95:定义函数
#!定义函数规则
#!1.函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。
#!2.任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。
#!3.函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
#!4.函数内容以冒号 : 起始，并且缩进。
#!5.return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。

# note96:定义函数语法
#*Python 定义函数使用 def 关键字，一般格式如下：
def 函数名（参数列表）:
    函数体
#*默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的
def hello() :
    print("Hello World!")
    #*设置函数时如果不需要返回任何值只需要写一个return，如果需要返回某一个数值或者公式，则在return后面输入相应数值
    return
hello()
#*更复杂点的应用，函数中带上参数变量
def max(a, b):
    if a > b:
        return a
    else:
        return b
a = 4
b = 5
print(max(a, b))
# *计算面积函数
def area(width, height):
    return width * height
def print_welcome(name):
    print("Welcome", name)
print_welcome("Runoob")
w = 4
h = 5
print("width =", w, " height =", h, " area =", area(w, h))

# note97:函数调用
#*定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。
#*这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。
#*如下实例调用了 printme() 函数
# 定义函数
def printme( str ):
    # 打印任何传入的字符串
    print (str)
    return
# 调用函数
printme("我要调用用户自定义函数!")
printme("再次调用同一函数")

# note98:参数传递
#*在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的：
a=[1,2,3]
a="Runoob"
#*以上代码中，[1,2,3] 是 List 类型，"Runoob" 是 String 类型，而变量 a 是没有类型，
#*她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。

# note99:可更改(mutable)与不可更改(immutable)对象
#*在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。
#*不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。
#*可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。
#*python 函数的参数传递：
#*不可变类型：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。
#*可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响
#*python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。

# note100:python传不可变对象实例
#*通过 id() 函数来查看内存地址变化：
def change(a):
    print(id(a))   # 指向的是同一个对象
    a=10
    print(id(a))   # 一个新对象
a=1
print(id(a))
change(a)
#*可以看见在调用函数前后，形参和实参指向的是同一个对象（对象 id 相同），在函数内部修改形参后，形参指向的是不同的 id

# note101:传可变对象实例
#*可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：
# 可写函数说明
def changeme( mylist ):
    "修改传入的列表"
    mylist.append([1,2,3,4])
    print ("函数内取值: ", mylist)
    return
# 调用changeme函数
mylist = [10,20,30]
changeme( mylist )
print ("函数外取值: ", mylist)

# note102:参数

#*必须参数
#*必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。
#*调用 printme() 函数，你必须传入一个参数，不然会出现语法错误：
#可写函数说明
#!无法执行该代码，因为调用函数的时候没有写入函数所需要的参数
def printme( str ):
    "打印任何传入的字符串"
    print (str)
    return
# 调用 printme 函数，不加参数会报错
printme()

#*关键参数
#*关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。
#*使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。
#*以下实例在函数 printme() 调用时使用参数名：
def printme( str ):
    "打印任何传入的字符串"
    print (str)
    return
#调用printme函数
printme( str = "教程")
#*以下实例中演示了函数参数的使用不需要使用指定顺序
#可写函数说明
def printinfo( name, age ):
    "打印任何传入的字符串"
    print ("名字: ", name)
    print ("年龄: ", age)
    return
#调用printinfo函数
printinfo( age=50, name="runoob" )

#*默认参数
#*调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值
#可写函数说明
def printinfo( name, age = 35 ):
    "打印任何传入的字符串"
    print ("名字: ", name)
    print ("年龄: ", age)
    return
#调用printinfo函数
printinfo( age=50, name="runoob" )
print ("------------------------")
printinfo( name="runoob" )

#*不定长参数
#*可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：
def functionname([formal_args,] *var_args_tuple ):
    "函数_文档字符串"
    function_suite
    return [expression]
#*加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数
# 可写函数说明
def printinfo( arg1, *vartuple ):
    "打印任何传入的参数"
    print ("输出: ")
    print (arg1)
    print (vartuple)
# 调用printinfo 函数
printinfo( 70, 60, 50 )
#*如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例
# 可写函数说明
def printinfo( arg1, *vartuple ):
    "打印任何传入的参数"
    print ("输出: ")
    print (arg1)
    for var in vartuple:
        print (var)
    return
# 调用printinfo 函数
printinfo( 10 )
printinfo( 70, 60, 50 )
#*还有一种就是参数带两个星号 **基本语法如下：
def functionname([formal_args,] **var_args_dict ):
    "函数_文档字符串"
    function_suite
return [expression]
#*加了两个星号 ** 的参数会以字典的形式导入
# 可写函数说明
def printinfo( arg1, **vardict ):
    "打印任何传入的参数"
    print ("输出: ")
    print (arg1)
    print (vardict)
# 调用printinfo 函数
printinfo(1, a=2,b=3)
#*声明函数时，参数中星号 * 可以单独出现，例如:
def f(a,b,*,c):
    return a+b+c

#*如果单独出现星号 *，则星号 * 后的参数必须用关键字传入
def f(a,b,*,c):
    return a+b+c
f(1,2,3)   # 报错
f(1,2,c=3) # 正常

# note103:匿名函数
#*Python 使用 lambda 来创建匿名函数。
#*所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。
#*lambda 只是一个表达式，函数体比 def 简单很多。
#*lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。
#*lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。
#*虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。
#*语法：
lambda [arg1 [,arg2,.....argn]]:expression
#*设置参数 a 加上 10
x = lambda a : a + 10
print(x(5))
#*以下实例匿名函数设置两个参数
# 可写函数说明
sum = lambda arg1, arg2: arg1 + arg2
# 调用sum函数
print ("相加后的值为 : ", sum( 10, 20 ))
print ("相加后的值为 : ", sum( 20, 20 ))
#*我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。
#*以下实例将匿名函数封装在 myfunc 函数中，通过传入不同的参数来创建不同的匿名函数
def myfunc(n):
  return lambda a : a * n
mydoubler = myfunc(2)
mytripler = myfunc(3)
print(mydoubler(11))
print(mytripler(11))

# note104:return语句
#*return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。
#*不带参数值的 return 语句返回 None。
#*之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法
# 可写函数说明
def sum( arg1, arg2 ):
    # 返回2个参数的和."
    total = arg1 + arg2
    print ("函数内 : ", total)
    return total
# 调用sum函数
total = sum( 10, 20 )
print ("函数外 : ", total)

# note105:强制位置参数
#*Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。
#*在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参:
def f(a = 10, b = 20, c = 30, d = 40, e = 50, f = 60):
    print(f)

# done17:数据结构
# note106:列表
#*Python中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能。
#*以下是 Python 中列表的方法
方法	            描述
list.append(x)	   把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。
list.extend(L)	   通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。
list.insert(i, x)  在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。
list.remove(x)	   删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。
list.pop([i])	   从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）
list.clear()	   移除列表中的所有项，等于del a[:]。
list.index(x)	   返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。
list.count(x)	   返回 x 在列表中出现的次数。
list.sort()	       对列表中的元素进行排序。
list.reverse()	   倒排列表中的元素。
list.copy()	       返回列表的浅复制，等于a[:]。
#*实例
a = [66.25, 333, 333, 1, 1234.5]
print(a.count(333), a.count(66.25), a.count('x'))
a.insert(2, -1)
a.append(333)
a
a.index(333)
a.remove(333)
a
a.reverse()
a
a.sort()
a
#!注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值

# note107:将列表当作堆栈来使用
#*列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。
#*用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。例如：
stack = [3, 4, 5]
stack.append(6)
stack.append(7)
stack
stack.pop()
stack
stack.pop()
stack.pop()
stack

# note108:将列表当作队列使用
#*也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。
#*在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）
from collections import deque
queue = deque(["Eric", "John", "Michael"])
queue.append("Terry")           # Terry arrives
queue.append("Graham")          # Graham arrives
queue.popleft()                 # The first to arrive now leaves
queue.popleft()                 # The second to arrive now leaves
queue                           # Remaining queue in order of arrival

# note109:列表推导式
#*列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。
#*每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。
#*返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。
#*果希望表达式推导出一个元组，就必须使用括号。
#*这里我们将列表中每个数值乘三，获得一个新的列表：
vec = [2, 4, 6]
[3*x for x in vec]
#*这里我们对序列里每一个元素逐个调用某方法
freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
[weapon.strip() for weapon in freshfruit]
#*可以用 if 子句作为过滤器
[3*x for x in vec if x > 3]
[3*x for x in vec if x < 2]
#*以下是一些关于循环和其它技巧的演示
vec1 = [2, 4, 6]
vec2 = [4, 3, -9]
[x*y for x in vec1 for y in vec2]
[x+y for x in vec1 for y in vec2]
[vec1[i]*vec2[i] for i in range(len(vec1))]
#*列表推导式可以使用复杂表达式或嵌套函数
[str(round(355/113, i)) for i in range(1, 6)]

# note110:嵌套列表解析
#*Python的列表还可以嵌套。
#*以下实例展示了3X4的矩阵列表
matrix = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9, 10, 11, 12],
    ]
print(matrix)
#*以下实例将3X4的矩阵列表转换为4X3列表
[[row[i] for row in matrix] for i in range(4)]
#*以上实例也可以使用以下方法来实现
transposed = []
for i in range(4):
    transposed.append([row[i] for row in matrix])
transposed
#*另外一种实现方法
transposed = []
for i in range(4):
    # the following 3 lines implement the nested listcomp
    transposed_row = []
    for row in matrix:
        transposed_row.append(row[i])
    transposed.append(transposed_row)
transposed

# note111:del 语句
#*使用 del 语句可以从一个列表中根据索引来删除一个元素，而不是值来删除元素。
#*这与使用 pop() 返回一个值不同。可以用 del 语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）
a = [-1, 1, 66.25, 333, 333, 1234.5]
del a[0]
print(a)
del a[2:4]
print(a)
del a[:]
print(a)

# note112:元组和序列
#*元组由若干逗号分隔的值组成，例如
t = 12345, 54321, 'hello!'
t[0]
print(t)
# Tuples may be nested:
u = t, (1, 2, 3, 4, 5)
print(u)
#*元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号， 不过括号通常是必须的（如果元组是更大的表达式的一部分）

# note113:集合
#*集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。
#*可以用大括号({})创建集合。
#!注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)                      # 删除重复的
'orange' in basket                 # 检测成员
'crabgrass' in basket
# 以下演示了两个集合的操作
a = set('abracadabra')
b = set('alacazam')
a                                  # a 中唯一的字母
a - b                              # 在 a 中的字母，但不在 b 中
a | b                              # 在 a 或 b 中的字母
a & b                              # 在 a 和 b 中都有的字母
a ^ b                              # 在 a 或 b 中的字母，但不同时在 a 和 b 中
#*集合也支持推导式
a = {x for x in 'abracadabra' if x not in 'abc'}
a

# note114:字典
#*序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。
#*理解字典的最佳方式是把它看做无序的键=>值对集合。在同一个字典之内，关键字必须是互不相同。
#*一对大括号创建一个空的字典：{}。
tel = {'jack': 4098, 'sape': 4139}
tel['guido'] = 4127
print(tel)
tel['jack']
del tel['sape']
tel['irv'] = 4127
print(tel)
list(tel.keys())
sorted(tel.keys())
'guido' in tel
'jack' not in tel
#*构造函数 dict() 直接从键值对元组列表中构建字典。
#*如果有固定的模式，列表推导式指定特定的键值对
dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
#*此外，字典推导可以用来创建任意键和值的表达式词典
{x: x**2 for x in (2, 4, 6)}
#*如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便
dict(sape=4139, guido=4127, jack=4098)

# note115:遍历技巧
#*在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来
knights = {'gallahad': 'the pure', 'robin': 'the brave'}
for k, v in knights.items():
    print(k, v)
#*在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)
#*同时遍历两个或更多的序列，可以使用 zip() 组合
questions = ['name', 'quest', 'favorite color']
answers = ['lancelot', 'the holy grail', 'blue']
for q, a in zip(questions, answers):
    print('What is your {0}?  It is {1}.'.format(q, a))
#*要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数
for i in reversed(range(1, 10, 2)):
    print(i)
#*要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值
basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
for f in sorted(set(basket)):
    print(f)

# done18:模块
# note116:模块介绍
#*模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。
#*模块可以被别的程序引入，以使用该模块中的函数等功能。
#*这也是使用 python 标准库的方法。
#*下面是一个使用 python 标准库中模块的例子
import sys
print('命令行参数如下:')
for i in sys.argv:
    print(i)
print('\n\nPython 路径为：', sys.path, '\n')
#*解释
#*1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。
#*2、sys.argv 是一个包含命令行参数的列表。
#*3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。

# note117:import语句
#*想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：
import module1[, module2[,... moduleN]
#*当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。
#*搜索路径是一个解释器会先进行搜索的所有目录的列表。
#*如想要导入模块 support，需要把命令放在脚本的顶端
# Filename: support.py
def print_func( par ):
    print ("Hello : ", par)
    return
#*test.py 引入 support 模块：
# Filename: test.py
# 导入模块
import support
# 现在可以调用模块里包含的函数了
support.print_func("Runoob")
#*一个模块只会被导入一次，不管你执行了多少次 import。这样可以防止导入模块被一遍又一遍地执行。
#*当使用 import 语句的时候，Python 解释器是怎样找到对应的文件的呢？
#*这就涉及到 Python 的搜索路径，搜索路径是由一系列目录名组成的，Python 解释器就依次从这些目录中去寻找所引入的模块。
#*这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。
#*搜索路径是在 Python 编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在 sys 模块中的 path 变量，做一个简单的实验，在交互式解释器中，输入以下代码
import sys
sys.path #*导出sys存储路径
#*sys.path 输出是一个列表，其中第一项是空串 ''，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。
#*因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。
#*了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。
#*现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个fibo.py的文件，代码如下
# 斐波那契(fibonacci)数列模块
def fib(n):    # 定义到 n 的斐波那契数列
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()
def fib2(n): # 返回到 n 的斐波那契数列
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result
#*然后进入Python解释器，使用下面的命令导入这个模块
import fibo
#*这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。
#*可以使用模块名称来访问函数
import fibo
fibo.fib(1000) #*使用斐波那契数列模块
fibo.__name__ #*输出斐波那契数列模块.py文件名称
#*打算经常使用一个函数，可以把它赋给一个本地的名称
fib = fibo.fib
fib(500)

# note118:from … import 语句
#*Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：
from modname import name1[, name2[, ... nameN]]
#*要导入模块 fibo 的 fib 函数，使用如下语句
from fibo import fib, fib2
fib(500)
#*这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进

# note119:from … import * 语句
#*把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：
from modname import *
#*这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。

# note120:深入模块
#*模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。
#*每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。
#*所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。
#*从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。
#*模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。
#*还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如
from fibo import fib, fib2
fib(500)
#*这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。
#*这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:
from fibo import *
fib(500)
#*这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。
#*大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义

# note121:__name__属性
#*一个模块被另一个程序第一次引入时，其主程序将运行。
#*如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。
# Filename: using_name.py
if __name__ == '__main__':
    print('程序自身在运行')
else:
    print('我来自另一模块')
#*运行输出如下
$ python using_name.py
程序自身在运行
$ python
>>> import using_name
我来自另一模块
>>>
#*说明： 每个模块都有一个__name__属性，当其值是'__main__'时，表明该模块自身在运行，否则是被引入。
#*说明：__name__ 与 __main__ 底下是双下划线， _ _ 是这样去掉中间的那个空格。

# note122:dir() 函数
#*内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:
import fibo, sys
dir(fibo)
dir(sys)
#*如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称
a = [1, 2, 3, 4, 5]
import fibo
fib = fibo.fib
dir() # 得到一个当前模块中定义的属性列表
a = 5 # 建立一个新的变量 'a'
dir()
del a # 删除变量名a
dir()


# note123:标准模块
#*Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的"库参考文档"）。
#*有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。
#*这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。
#*应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串
import sys
sys.ps1
sys.ps2
sys.ps1 = 'C> '
print('Runoob!')

# note124:包
#*包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。
#*比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。
#*就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。
#*这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。
#*不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个"包"）。
#*现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。
#*并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。
#*这里给出了一种可能的包结构（在分层的文件系统中）:
sound/                          顶层包
        __init__.py               初始化 sound 包
        formats/                  文件格式转换子包
                __init__.py
                wavread.py
                wavwrite.py
                aiffread.py
                aiffwrite.py
                auread.py
                auwrite.py
                ...
        effects/                  声音效果子包
                __init__.py
                echo.py
                surround.py
                reverse.py
                ...
        filters/                  filters 子包
                __init__.py
                equalizer.py
                vocoder.py
                karaoke.py
                ...
#*在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。
#*目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。
#*最简单的情况，放一个空的 :file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。
#*用户可以每次只导入一个包里面的特定模块，比如:
import sound.effects.echo
#*这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:
sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
#*还有一种导入子模块的方法是:
from sound.effects import echo
#*这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:
echo.echofilter(input, output, delay=0.7, atten=4)
#*还有一种变化就是直接导入一个函数或者变量:
from sound.effects.echo import echofilter
#*同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:
echofilter(input, output, delay=0.7, atten=4)
#*注意当使用 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。
import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 :exc:ImportError 异常。
#*反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。

# note125:从一个包中导入*
#*如果我们使用 from sound.effects import * 会发生什么呢？
#*Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。
#*但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。
#*在 Windows 平台上，我们无法确定一个叫做 ECHO.py 的文件导入为模块是 echo 还是 Echo，或者是 ECHO。
#*为了解决这个问题，我们只需要提供一个精确包的索引。
#*导入语句遵循如下规则：如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。
#*作为包的作者，可别忘了在更新包之后保证 __all__ 也更新了啊。
#*以下实例在 file:sounds/effects/__init__.py 中包含如下代码:
__all__ = ["echo", "surround", "reverse"]
#*这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。
#*如果 __all__ 真的没有定义，那么使用from sound.effects import *这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。
#*这会把 __init__.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:
import sound.effects.echo
import sound.effects.surround
from sound.effects import *
#*这个例子中，在执行 from...import 前，包 sound.effects 中的 echo 和 surround 模块都被导入到当前的命名空间中了。（当然如果定义了 __all__ 就更没问题了）
#*通常我们并不主张使用 * 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。
#*记住，使用 from Package import specific_submodule 这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。
#*如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包 sound.effects 中的模块 echo，你就要写成 from sound.effects import echo。
from . import echo
from .. import formats
from ..filters import equalizer
#*无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是"__main__"，一个Python应用程序的主模块，应当总是使用绝对路径引用。
#*包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的__init__.py，你得在其他__init__.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。
#*这个功能并不常用，一般用来扩展包里面的模块。

# done19:python输入与输出
#*在python中使用print进行输出，input进行输入
# note126:输出格式美化
#*Python两种输出值的方式: 表达式语句和 print() 函数。
#*第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。
#*如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。
#*如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。
#*str()： 函数返回一个用户易读的表达形式。
#*repr()： 产生一个解释器易读的表达形式。
#*例如
s = 'Hello, Runoob'
str(s)
repr(s)
str(1/7)
x = 10 * 3.25
y = 200 * 200
s = 'x 的值为： ' + repr(x) + ',  y 的值为：' + repr(y) + '...'
print(s)
#  repr() 函数可以转义字符串中的特殊字符
hello = 'hello, runoob\n'
hellos = repr(hello)
print(hellos)
# repr() 的参数可以是 Python 的任何对象
repr((x, y, ('Google', 'Runoob')))
#*这里有两种方式输出一个平方与立方的表
for x in range(1, 11):
    print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
    # 注意前一行 'end' 的使用
    print(repr(x*x*x).rjust(4))

#*另外一种方法
for x in range(1, 11):
    print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
#!注意：在第一个例子中, 每列间的空格由 print() 添加。
#*这个例子展示了字符串对象的 rjust() 方法, 它可以将字符串靠右, 并在左边填充空格。
#*还有类似的方法, 如 ljust() 和 center()。 这些方法并不会写任何东西, 它们仅仅返回新的字符串。
#*另一个方法 zfill(), 它会在数字的左边填充 0，如下所示：
'12'.zfill(5)
'-3.14'.zfill(7)
'3.14159265359'.zfill(5)
#*str.format() 的基本使用如下:
print('{}网址： "{}!"'.format('教程', 'www.runoob.com'))
#*括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。
#*在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：
print('{0} 和 {1}'.format('Google', 'Runoob'))
print('{1} 和 {0}'.format('Google', 'Runoob'))
#*如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。
print('{name}网址： {site}'.format(name='教程', site='www.runoob.com'))
#*位置及关键字参数可以任意的结合:
print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob', other='Taobao'))
#*!a (使用 ascii()), !s (使用 str()) 和 !r (使用 repr()) 可以用于在格式化某个值之前对其进行转化:
import math
print('常量 PI 的值近似为： {}。'.format(math.pi))
print('常量 PI 的值近似为： {!r}。'.format(math.pi))
#*可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：
import math
print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))
#*常量 PI 的值近似为 3.142。
#*在 : 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用。
table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
for name, number in table.items():
    print('{0:10} ==> {1:10d}'.format(name, number))
Google     ==>          1
Runoob     ==>          2
Taobao     ==>          3
#*如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。
#*最简单的就是传入一个字典, 然后使用方括号 [] 来访问键值 :
table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))
#*也可以通过在 table 变量前使用 ** 来实现相同的功能：
table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))

# note127:旧字符串格式化转换
#*% 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf() 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:
import math
print('常量 PI 的值近似为：%5.3f。' % math.pi)
#*因为 str.format() 是比较新的函数， 大多数的 Python 代码仍然使用 % 操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format()

# note128:读取键盘输入
#*Python 提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。
str = input("请输入：");
print ("你输入的内容是: ", str)

# note129:读和写文件
#*open() 将会返回一个 file 对象，基本语法格式如下:
open(filename, mode)
#*filename：包含了你要访问的文件名称的字符串值。
#*mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。
#*不同模式打开文件的完全列表：

#*模式	     描述
#*r	        以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
#*rb	    以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。
#*r+	    打开一个文件用于读写。文件指针将会放在文件的开头。
#*rb+	    以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。
#*w	        打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
#*wb	    以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
#*w+	    打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
#*wb+	    以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
#*a	        打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
#*ab	    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
#*a+	    打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
#*ab+	    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。

#*模式
模式	    r	r+	w	w+	a	a+
读	        +	+		+		+
写		    +	+	+	+	+
创建			    +	+	+	+
覆盖			    +	+
指针在开始	    +	 +	 +	 +
指针在结尾					+	+

#*以下实例将字符串写入到文件 foo.txt 中
# 打开一个文件
f = open("/tmp/foo.txt", "w")

f.write( "Python 是一个非常好的语言。\n是的，的确非常好!!\n" )

# 关闭打开的文件
f.close()
#*第一个参数为要打开的文件名。
#*第二个参数描述文件如何使用的字符。 mode 可以是 'r' 如果文件只读, 'w' 只用于写 (如果存在同名文件则将被删除), 和 'a' 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. 'r+' 同时用于读写。 mode 参数是可选的; 'r' 将是默认值。

# note130:文件对象的方法
#*本节(done)中剩下的例子假设已经创建了一个称为 f 的文件对象

#*f.read()
#*为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。
#*size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。
#*以下实例假定文件 foo.txt 已存在（上面实例中已创建）：
# 打开一个文件
f = open("/tmp/foo.txt", "r")

str = f.read()
print(str)

# 关闭打开的文件
f.close()

#*f.readline()
#*.readline() 会从文件中读取单独的一行。
#*换行符为 '\n'。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行
# 打开一个文件
f = open("/tmp/foo.txt", "r")

str = f.readline()
print(str)

# 关闭打开的文件
f.close()

#*f.readlines()
#*f.readlines() 将返回该文件中包含的所有行。
#*如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。
# 打开一个文件
f = open("/tmp/foo.txt", "r")

str = f.readlines()
print(str)

# 关闭打开的文件
f.close()

#*另一种方式是迭代一个文件对象然后读取每行:
# 打开一个文件
f = open("/tmp/foo.txt", "r")

for line in f:
    print(line, end='')

# 关闭打开的文件
f.close()
#!这个方法很简单, 但是并没有提供一个很好的控制。 因为两者的处理机制不同, 最好不要混用

#*f.write()
#*f.write(string) 将 string 写入到文件中, 然后返回写入的字符数
# 打开一个文件
f = open("/tmp/foo.txt", "w")

num = f.write( "Python 是一个非常好的语言。\n是的，的确非常好!!\n" )
print(num)
# 关闭打开的文件
f.close()
#*如果要写入一些不是字符串的东西, 那么将需要先进行转换
# 打开一个文件
f = open("/tmp/foo1.txt", "w")

value = ('www.runoob.com', 14)
s = str(value)
f.write(s)

# 关闭打开的文件
f.close()

#*f.tell()
#*f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。
#*f.seek()
#*如果要改变文件指针当前的位置, 可以使用 f.seek(offset, from_what) 函数。
#*from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：
#*seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符
#*seek(x,1) ： 表示从当前位置往后移动x个字符
#*seek(-x,2)：表示从文件的结尾往前移动x个字符
#*from_what 值为默认为0，即文件开头。下面给出一个完整的例子：
f = open('/tmp/foo.txt', 'rb+')
f.write(b'0123456789abcdef')
f.seek(5)     # 移动到文件的第六个字节
f.read(1)
f.seek(-3, 2) # 移动到文件的倒数第三字节
f.read(1)

#*f.close()
#*在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。
#*当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。
f.close()
f.read()
#*当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短:
with open('/tmp/foo.txt', 'r') as f:
    read_data = f.read()
f.closed
#*文件对象还有其他方法, 如 isatty() 和 trucate(), 但这些通常比较少用

#*pickle 模块
#*python的pickle模块实现了基本的数据序列和反序列化。
#*通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。
#*通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。
#*基本接口：
pickle.dump(obj, file, [,protocol])
#*有了 pickle 这个对象, 就能对 file 以读取的形式打开:
x = pickle.load(file)
#*注解：从 file 中读取一个字符串，并将它重构为原来的python对象。
#*file: 类文件对象，有read()和readline()接口。

# done20:Python3 File(文件) 方法
# note131:open() 方法
#*Python open() 方法用于打开一个文件，并返回文件对象。
#*在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。
#!注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。
#*open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。
open(file, mode='r')
#*完整的语法格式为：
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
#*参数说明:
#*file: 必需，文件路径（相对或者绝对路径）。
#*mode: 可选，文件打开模式
#*buffering: 设置缓冲
#*encoding: 一般使用utf8
#*errors: 报错级别
#*newline: 区分换行符
#*closefd: 传入的file参数类型
#*opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。

#*mode 参数有：
#*模式	 描述
#*t	    文本模式 (默认)。
#*x	    写模式，新建一个文件，如果该文件已存在则会报错。
#*b	    二进制模式。
#*+	    打开一个文件进行更新(可读可写)。
#*U	    通用换行模式（Python 3 不支持）。
#*r	    以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
#*rb	以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。
#*r+	打开一个文件用于读写。文件指针将会放在文件的开头。
#*rb+	以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。
#*w	    打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
#*wb	以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。
#*w+	打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
#*wb+	以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。
#*a	    打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
#*ab	以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
#*a+	打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
#*ab+	以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。

#*默认为文本模式，如果要以二进制模式打开，加上 b

#*file 对象
#*file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：
1	
file.close()
关闭文件。关闭后文件不能再进行读写操作。
2	
file.flush()
刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。
3	
file.fileno()
返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。
4	
file.isatty()
如果文件连接到一个终端设备返回 True，否则返回 False。
5	
file.next()
Python 3 中的 File 对象不支持 next() 方法。
返回文件下一行。
6	
file.read([size])
从文件读取指定的字节数，如果未给定或为负则读取所有。
7	
file.readline([size])
读取整行，包括 "\n" 字符。
8	
file.readlines([sizeint])
读取所有行并返回列表，若给定sizeint>0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。
9	
file.seek(offset[, whence])
移动文件读取指针到指定位置
10	
file.tell()
返回文件当前位置。
11	
file.truncate([size])
从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。
12	
file.write(str)
将字符串写入文件，返回的是写入的字符长度。
13	
file.writelines(sequence)
向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。

#done21:Python3 OS 文件/目录方法
# note132:处理文件方式介绍
#!模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示
序号	方法及描述
1	
os.access(path, mode)

检验权限模式
2	
os.chdir(path)

改变当前工作目录
3	
os.chflags(path, flags)

设置路径的标记为数字标记。
4	
os.chmod(path, mode)

更改权限
5	
os.chown(path, uid, gid)

更改文件所有者
6	
os.chroot(path)

改变当前进程的根目录
7	
os.close(fd)

关闭文件描述符 fd
8	
os.closerange(fd_low, fd_high)

关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略
9	
os.dup(fd)

复制文件描述符 fd
10	
os.dup2(fd, fd2)

将一个文件描述符 fd 复制到另一个 fd2
11	
os.fchdir(fd)

通过文件描述符改变当前工作目录
12	
os.fchmod(fd, mode)

改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。
13	
os.fchown(fd, uid, gid)

修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。
14	
os.fdatasync(fd)

强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。
15	
os.fdopen(fd[, mode[, bufsize]])

通过文件描述符 fd 创建一个文件对象，并返回这个文件对象
16	
os.fpathconf(fd, name)

返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。
17	
os.fstat(fd)

返回文件描述符fd的状态，像stat()。
18	
os.fstatvfs(fd)

返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。
19	
os.fsync(fd)

强制将文件描述符为fd的文件写入硬盘。
20	
os.ftruncate(fd, length)

裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。
21	
os.getcwd()

返回当前工作目录
22	
os.getcwdb()

返回一个当前工作目录的Unicode对象
23	
os.isatty(fd)

如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。
24	
os.lchflags(path, flags)

设置路径的标记为数字标记，类似 chflags()，但是没有软链接
25	
os.lchmod(path, mode)

修改连接文件权限
26	
os.lchown(path, uid, gid)

更改文件所有者，类似 chown，但是不追踪链接。
27	
os.link(src, dst)

创建硬链接，名为参数 dst，指向参数 src
28	
os.listdir(path)

返回path指定的文件夹包含的文件或文件夹的名字的列表。
29	
os.lseek(fd, pos, how)

设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效
30	
os.lstat(path)

像stat(),但是没有软链接
31	
os.major(device)

从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。
32	
os.makedev(major, minor)

以major和minor设备号组成一个原始设备号
33	
os.makedirs(path[, mode])

递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。
34	
os.minor(device)

从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。
35	
os.mkdir(path[, mode])

以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。
36	
os.mkfifo(path[, mode])

创建命名管道，mode 为数字，默认为 0666 (八进制)
37	
os.mknod(filename[, mode=0600, device])
创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。
38	
os.open(file, flags[, mode])

打开一个文件，并且设置需要的打开选项，mode参数是可选的
39	
os.openpty()

打开一个新的伪终端对。返回 pty 和 tty的文件描述符。
40	
os.pathconf(path, name)

返回相关文件的系统配置信息。
41	
os.pipe()

创建一个管道. 返回一对文件描述符(r, w) 分别为读和写
42	
os.popen(command[, mode[, bufsize]])

从一个 command 打开一个管道
43	
os.read(fd, n)

从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。
44	
os.readlink(path)

返回软链接所指向的文件
45	
os.remove(path)

删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。
46	
os.removedirs(path)

递归删除目录。
47	
os.rename(src, dst)

重命名文件或目录，从 src 到 dst
48	
os.renames(old, new)

递归地对目录进行更名，也可以对文件进行更名。
49	
os.rmdir(path)

删除path指定的空目录，如果目录非空，则抛出一个OSError异常。
50	
os.stat(path)

获取path指定的路径的信息，功能等同于C API中的stat()系统调用。
51	
os.stat_float_times([newvalue])
决定stat_result是否以float对象显示时间戳
52	
os.statvfs(path)

获取指定路径的文件系统统计信息
53	
os.symlink(src, dst)

创建一个软链接
54	
os.tcgetpgrp(fd)

返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组
55	
os.tcsetpgrp(fd, pg)

设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。
56	
os.tempnam([dir[, prefix]])

Python3 中已删除。返回唯一的路径名用于创建临时文件。
57	
os.tmpfile()

Python3 中已删除。返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。
58	
os.tmpnam()

Python3 中已删除。为创建一个临时文件返回一个唯一的路径
59	
os.ttyname(fd)

返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。
60	
os.unlink(path)

删除文件路径
61	
os.utime(path, times)

返回指定的path文件的访问和修改的时间。
62	
os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])

输出在文件夹中的文件名通过在树中游走，向上或者向下。
63	
os.write(fd, str)

写入字符串到文件描述符 fd中. 返回实际写入的字符串长度
64	
os.path 模块

获取文件的属性信息。
65	
os.pardir()

#*获取当前目录的父目录，以字符串形式显示目录名。

# note133:Python3 os.access() 方法
#*概述
os.access() 方法使用当前的uid/gid尝试访问路径。大部分操作使用有效的 uid/gid, 因此运行环境可以在 suid/sgid 环境尝试。
#*语法
access()方法语法格式如下：
os.access(path, mode);
#*参数
path -- 要用来检测是否有访问权限的路径。
mode -- mode为F_OK，测试存在的路径，或者它可以是包含R_OK, W_OK和X_OK或者R_OK, W_OK和X_OK其中之一或者更多。
os.F_OK: 作为access()的mode参数，测试path是否存在。
os.R_OK: 包含在access()的mode参数中 ， 测试path是否可读。
os.W_OK 包含在access()的mode参数中 ， 测试path是否可写。
os.X_OK 包含在access()的mode参数中 ，测试path是否可执行。
#*返回值
#*如果允许访问返回 True , 否则返回False。
#*实例
#*以下实例演示了 access() 方法的使用：

import os, sys

# 假定 /tmp/foo.txt 文件存在，并有读写权限

ret = os.access("/tmp/foo.txt", os.F_OK)
print ("F_OK - 返回值 %s"% ret)

ret = os.access("/tmp/foo.txt", os.R_OK)
print ("R_OK - 返回值 %s"% ret)

ret = os.access("/tmp/foo.txt", os.W_OK)
print ("W_OK - 返回值 %s"% ret)

ret = os.access("/tmp/foo.txt", os.X_OK)
print ("X_OK - 返回值 %s"% ret)

# note134:Python3 os.chdir() 方法
#*概述
os.chdir() 方法用于改变当前工作目录到指定的路径。
#*语法
#*chdir()方法语法格式如下：
os.chdir(path)
#*参数
#*path -- 要切换到的新路径。
#*返回值
#*如果允许访问返回 True , 否则返回False。
#*实例
#*以下实例演示了 chdir() 方法的使用：

import os, sys

path = "/tmp"

# 查看当前工作目录
retval = os.getcwd()
print ("当前工作目录为 %s" % retval)

# 修改当前工作目录
os.chdir( path )

# 查看修改后的工作目录
retval = os.getcwd()

print ("目录修改成功 %s" % retval)

# note135:Python3 os.chflags() 方法
#*Python3 OS 文件/目录方法 Python3 OS 文件/目录方法
#*概述
#*os.chflags() 方法用于设置路径的标记为数字标记。多个标记可以使用 OR 来组合起来。
#*只支持在 Unix 下使用。
#*语法
chflags()方法语法格式如下：
os.chflags(path, flags)
#*参数
#*path -- 文件名路径或目录路径。
#*flags -- 可以是以下值：
#*stat.UF_NODUMP: 非转储文件
#*stat.UF_IMMUTABLE: 文件是只读的
#*stat.UF_APPEND: 文件只能追加内容
#*stat.UF_NOUNLINK: 文件不可删除
#*stat.UF_OPAQUE: 目录不透明，需要通过联合堆栈查看
#*stat.SF_ARCHIVED: 可存档文件(超级用户可设)
#*stat.SF_IMMUTABLE: 文件是只读的(超级用户可设)
#*stat.SF_APPEND: 文件只能追加内容(超级用户可设)
#*stat.SF_NOUNLINK: 文件不可删除(超级用户可设)
#*stat.SF_SNAPSHOT: 快照文件(超级用户可设)
#*返回值
#*该方法没有返回值。
#*实例
#*以下实例演示了 chflags() 方法的使用：

import os,stat

path = "/tmp/foo.txt"

# 为文件设置标记，使得它不能被重命名和删除
flags = stat.SF_NOUNLINK
retval = os.chflags( path, flags )
print ("返回值: %s" % retval)

# note136:Python3 os.chmod() 方法
#*Python3 OS 文件/目录方法 Python3 OS 文件/目录方法
#*概述
o#*s.chmod() 方法用于更改文件或目录的权限。
#*Unix 系统可用。
#*语法
chmod()方法语法格式如下：
os.chmod(path, mode)
#*参数
#*path -- 文件名路径或目录路径。
#*flags -- 可用以下选项按位或操作生成， 目录的读权限表示可以获取目录里文件名列表， ，执行权限表示可以把工作目录切换到此目录 ，删除添加目录里的文件必须同时有写和执行权限 ，文件权限以用户id->组id->其它顺序检验,最先匹配的允许或禁止权限被应用。
#*stat.S_IXOTH: 其他用户有执行权0o001
#*stat.S_IWOTH: 其他用户有写权限0o002
#*stat.S_IROTH: 其他用户有读权限0o004
#*stat.S_IRWXO: 其他用户有全部权限(权限掩码)0o007
#*stat.S_IXGRP: 组用户有执行权限0o010
#*stat.S_IWGRP: 组用户有写权限0o020
#*stat.S_IRGRP: 组用户有读权限0o040
#*stat.S_IRWXG: 组用户有全部权限(权限掩码)0o070
#*stat.S_IXUSR: 拥有者具有执行权限0o100
#*stat.S_IWUSR: 拥有者具有写权限0o200
#*stat.S_IRUSR: 拥有者具有读权限0o400
#*stat.S_IRWXU: 拥有者有全部权限(权限掩码)0o700
#*stat.S_ISVTX: 目录里文件目录只有拥有者才可删除更改0o1000
#*stat.S_ISGID: 执行此文件其进程有效组为文件所在组0o2000
#*stat.S_ISUID: 执行此文件其进程有效用户为文件所有者0o4000
#*stat.S_IREAD: windows下设为只读
#*stat.S_IWRITE: windows下取消只读
#*返回值
#*该方法没有返回值。
#*实例
#*以下实例演示了 chmod() 方法的使用：

import os, sys, stat

# 假定 /tmp/foo.txt 文件存在，设置文件可以通过用户组执行

os.chmod("/tmp/foo.txt", stat.S_IXGRP)

# 设置文件可以被其他用户写入
os.chmod("/tmp/foo.txt", stat.S_IWOTH)

print ("修改成功!!")

# note137:Python3 os.chown() 方法
#*Python3 OS 文件/目录方法 Python3 OS 文件/目录方法
#*概述
#*os.chown() 方法用于更改文件所有者，如果不修改可以设置为 -1, 你需要超级用户权限来执行权限修改操作。
#*只支持在 Unix 下使用。
#*语法
#*chown()方法语法格式如下：
#*os.chown(path, uid, gid);
#*参数
#*path -- 设置权限的文件路径
#*uid -- 所属用户 ID
#*gid -- 所属用户组 ID
#*返回值
#*该方法没有返回值。
#*实例
#*以下实例演示了 chown() 方法的使用：

import os, sys

# 假定 /tmp/foo.txt 文件存在.
# 设置所有者 ID 为 100
os.chown("/tmp/foo.txt", 100, -1)

print ("修改权限成功!!")

# note138:Python3 os.chroot() 方法
#*Python3 OS 文件/目录方法 Python3 OS 文件/目录方法
#*概述
#*os.chroot() 方法用于更改当前进程的根目录为指定的目录，使用该函数需要管理员权限。
#*在 unix 中有效。
#*语法
#*chroot()方法语法格式如下：
#*os.chroot(path);
#*参数
#*path -- 要设置为根目录的目录。
#*返回值
#*该方法没有返回值。
#*实例
#*以下实例演示了 chroot() 方法的使用：

import os, sys

# 设置根目录为 /tmp

os.chroot("/tmp")

print ("修改根目录成功!!")

# note139:Python3 os.close() 方法
#*Python3 OS 文件/目录方法 Python3 OS 文件/目录方法
#*概述
#*os.close() 方法用于关闭指定的文件描述符 fd。
#*语法
#*close()方法语法格式如下：
#*os.close(fd);
#*参数
#*fd -- 文件描述符。
#*返回值
#*该方法没有返回值。
#*实例
#*以下实例演示了 close() 方法的使用：
#*实例

import os, sys

# 打开文件
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )

#  写入字符串
os.write(fd, "This is test")

# 关闭文件
os.close( fd )

print ("关闭文件成功!!")

# note140:Python3 os.closerange() 方法
#*Python3 OS 文件/目录方法 Python3 OS 文件/目录方法
#*概述
#*os.closerange() 方法用于关闭所有文件描述符 fd，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略。
#*语法
#*closerange()方法语法格式如下：
#*os.closerange(fd_low, fd_high);
#*参数
#*fd_low -- 最小文件描述符
#*fd_high -- 最大文件描述符
#*该方法类似于：
for fd in xrange(fd_low, fd_high):
    try:
        os.close(fd)
    except OSError:
        pass
#*返回值
#*该方法没有返回值。
#*实例
#*以下实例演示了 closerange() 方法的使用：

import os, sys

# 打开文件
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )

# 写入字符串
os.write(fd, "This is test")

# 关闭文件
os.closerange( fd, fd)

print ("关闭文件成功!!")

# note141:Python3 os.dup() 方法
#*Python3 OS 文件/目录方法 Python3 OS 文件/目录方法
#*概述
#*os.dup() 方法用于复制文件描述符 fd。
#*语法
#*dup()方法语法格式如下：
#*os.dup(fd);
#*参数
#*fd -- 文件描述符
#*返回值
#*返回复制的文件描述符。
#*实例
#*以下实例演示了 dup() 方法的使用：
#*实例(Python 3.0+)

import os, sys

# 打开文件
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )

# 复制文件描述符
d_fd = os.dup( fd )

# 使用复制的文件描述符写入文件
os.write(d_fd, "This is test".encode())

# 关闭文件
os.closerange( fd, d_fd)

print ("关闭所有文件成功!!")

# note142:Python3 os.dup2() 方法
#*Python3 OS 文件/目录方法 Python3 OS 文件/目录方法
#*概述
#*os.dup2() 方法用于将一个文件描述符 fd 复制到另一个 fd2。
#*Unix, Windows 上可用。
#*语法
#*dup2()方法语法格式如下：
#*os.dup2(fd, fd2);
#*参数
#*fd -- 要被复制的文件描述符
#*fd2 -- 复制的文件描述符
#*返回值
#*没有返回值。
#*实例
#*以下实例演示了 dup2() 方法的使用：
#*实例
import os

# 打开一个文件
f=open('txt','a')

# 将这个文件描述符代表的文件，传递给 1 描述符指向的文件（也就是 stdout）
os.dup2(f.fileno(), 1)

# 关闭文件
f.close()

# print 输出到标准输出流，就是文件描述符1
print('runoob')
print('google')

# note143:Python3 os.fchdir() 方法
#*Python3 OS 文件/目录方法 Python3 OS 文件/目录方法
#*概述
#*os.fchdir() 方法通过文件描述符改变当前工作目录。
#*Unix 上可用。
#*语法
fchdir()方法语法格式如下：
os.fchdir(fd);
#*参数
#*fd -- 文件描述符
#*返回值
#*该方法没有返回值。
#*实例
#*以下实例演示了 fchdir() 方法的使用：

import os, sys

# 首先到目录 "/var/www/html"
os.chdir("/var/www/html" )

# 输出当前目录
print ("当前工作目录为 : %s" % os.getcwd())

# 打开新目录 "/tmp"
fd = os.open( "/tmp", os.O_RDONLY )

# 使用 os.fchdir() 方法修改到新目录
os.fchdir(fd)

# 输出当前目录
print ("当前工作目录为 : %s" % os.getcwd())

# 关闭打开的目录
os.close( fd )

# note144:os.fchmod(fd, mode)

# note145:os.fchown(fd, uid, gid)

# note146:os.fdatasync(fd)

# note147:os.fdopen(fd[, mode[, bufsize]])

# note148:os.fpathconf(fd, name)

# note149:os.fstat(fd)

# note150:os.fstatvfs(fd)

# note151:os.fsync(fd)

# note152:os.ftruncate(fd, length)

# note153:os.getcwd()

# note154:os.getcwdb()

# note155:os.isatty(fd)

# note156:os.lchflags(path, flags)

# note157:os.lchmod(path, mode)

# note158:os.lchown(path, uid, gid)

# note159:os.link(src, dst)

# note160:os.listdir(path)

# note160:os.lseek(fd, pos, how)

# note161:os.lstat(path)

# note162:os.major(device)

# note163:os.makedev(major, minor)

# note164:os.makedirs(path[, mode])

# note165:os.minor(device)

# note166:os.mkdir(path[, mode])

# note167:os.mkfifo(path[, mode])

# note168:os.mknod(filename[, mode=0600, device])

# note169:os.open(file, flags[, mode])

# note170:os.openpty()

# note171:os.pathconf(path, name)

# note172:os.pipe()

# note173:os.popen(command[, mode[, bufsize]])

# note174:os.read(fd, n)

# note175:os.readlink(path)

# note176:os.remove(path)

# note177:os.removedirs(path)

# note178:os.rename(src, dst)

# note179:os.renames(old, new)

# note180:os.rmdir(path)

# note181:os.stat(path)

# note182:os.stat_float_times([newvalue])

# note183:os.statvfs(path)

# note184:os.symlink(src, dst)

# note185:os.tcgetpgrp(fd)

# note186:os.tcsetpgrp(fd, pg)

# note187:os.ttyname(fd)

# note188:os.unlink(path)

# note189:os.utime(path, times)

# note190:os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])

# note191:os.write(fd, str)

# note192:os.path 模块

# note193:os.pardir()

# done22:python错误与异常
# note194:语法错误
>>> while True print('Hello world')
File "<stdin>", line 1, in ?
    while True print('Hello world')
                   ^
SyntaxError: invalid syntax
#*这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号 : 。
#*语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。

# note195:异常
#*即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。
#*大多数的异常都不会被程序处理，都以错误信息的形式展现在这里:
#*实例
>>> 10 * (1/0)             # 0 不能作为除数，触发异常
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ZeroDivisionError: division by zero
>>> 4 + spam*3             # spam 未定义，触发异常
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
NameError: name 'spam' is not defined
>>> '2' + 2               # int 不能与 str 相加，触发异常
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate str (not "int") to str
#*异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有 ZeroDivisionError，NameError 和 TypeError。
#*错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。

# note196:异常处理
#*try/except
#*异常捕捉可以使用 try/except 语句。
#*以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。
while True:
    try:
        x = int(input("请输入一个数字: "))
        break
    except ValueError:
        print("您输入的不是数字，请再次尝试输入！")
#*try 语句按照如下方式工作；
#*首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。
#*如果没有异常发生，忽略 except 子句，try 子句执行后结束。
#*如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。
#*如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。
#*一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。
#*处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。
#*一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:
except (RuntimeError, TypeError, NameError):
    pass
#*最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。
import sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print("OS error: {0}".format(err))
except ValueError:
    print("Could not convert data to an integer.")
except:
    print("Unexpected error:", sys.exc_info()[0])
    raise

#*try/except...else
#*try/except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。
#*else 子句将在 try 子句没有发生任何异常的时候执行。
#*以下实例在 try 语句中判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句，读取文件内容：
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except IOError:
        print('cannot open', arg)
    else:
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()
#*使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。
#*异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:
def this_fails():
        x = 1/0
try:
        this_fails()
    except ZeroDivisionError as err:
        print('Handling run-time error:', err)
#*try-finally 语句
#*try-finally 语句无论是否发生异常都将执行最后的代码。
#*以下实例中 finally 语句无论异常是否发生都会执行
try:
    runoob()
except AssertionError as error:
    print(error)
else:
    try:
        with open('file.log') as file:
            read_data = file.read()
    except FileNotFoundError as fnf_error:
        print(fnf_error)
finally:
    print('这句话，无论异常是否发生都会执行。')

# note197:抛出异常
#*Python 使用 raise 语句抛出一个指定的异常。
#*raise语法格式如下：
raise [Exception [, args [, traceback]]]
#*以下实例如果 x 大于 5 就触发异常:
x = input("请输入数值:")
x = int(x)
if x > 5:
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
else:
    print(f"您输入的数字为:{x}")

#*执行以上代码会触发异常：
Traceback (most recent call last):
File "test.py", line 3, in <module>
raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
Exception: x 不能大于 5。x 的值为: 10
raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。
如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。
>>> try:
        raise NameError('HiThere')
    except NameError:
        print('An exception flew by!')
        raise
An exception flew by!
Traceback (most recent call last):
File "<stdin>", line 2, in ?
NameError: HiThere

# note198:用户自定义异常
#*可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如:
>>> class MyError(Exception):
        def __init__(self, value):
            self.value = value
        def __str__(self):
            return repr(self.value)
>>> try:
        raise MyError(2*2)
    except MyError as e:
        print('My exception occurred, value:', e.value)
My exception occurred, value: 4
>>> raise MyError('oops!')
Traceback (most recent call last):
File "<stdin>", line 1, in ?
__main__.MyError: 'oops!'
#*在这个例子中，类 Exception 默认的 __init__() 被覆盖。
#*当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:
class Error(Exception):
    """Base class for exceptions in this module."""
    pass

class InputError(Error):
    """Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    """

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class TransitionError(Error):
    """Raised when an operation attempts a state transition that's not
    allowed.

    Attributes:
        previous -- state at beginning of transition
        next -- attempted new state
        message -- explanation of why the specific transition is not allowed
    """

    def __init__(self, previous, next, message):
        self.previous = previous
        self.next = next
        self.message = message
#*大多数的异常的名字都以"Error"结尾，就跟标准的异常命名一样。

# note199:定义清理行为
#*ry 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如:
>>> try:
...     raise KeyboardInterrupt
... finally:
...     print('Goodbye, world!')
... 
Goodbye, world!
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
KeyboardInterrupt
#*以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。
#*如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。
#*下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally 子句）:
>>> def divide(x, y):
        try:
            result = x / y
        except ZeroDivisionError:
            print("division by zero!")
        else:
            print("result is", result)
        finally:
            print("executing finally clause")
>>> divide(2, 1)
result is 2.0
executing finally clause
>>> divide(2, 0)
division by zero!
executing finally clause
>>> divide("2", "1")
executing finally clause
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "<stdin>", line 3, in divide
TypeError: unsupported operand type(s) for /: 'str' and 'str'

# note200:预定义的清理行为
#*一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。
#*下面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:
for line in open("myfile.txt"):
    print(line, end="")
#*以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。
#*关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:
with open("myfile.txt") as f:
    for line in f:
        print(line, end="")
#*以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。

# done23:类与对象
# note201:面向对象技术介绍
#*类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
#*方法：类中定义的函数。
#*类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
#*数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。
#*方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
#*局部变量：定义在方法中的变量，只作用于当前实例的类。
#*实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。
#*继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。
#*实例化：创建一个类的实例，类的具体对象。
#*对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。
#*和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。
#*Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。
#*对象可以包含任意数量和类型的数据。

# note202:类定义
#*语法格式如下：
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
#*类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。

# note203:类对象
#*类对象支持两种操作：属性引用和实例化。
#*属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。
#*类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:
class MyClass:
    """一个简单的类实例"""
    i = 12345
    def f(self):
        return 'hello world'
# 实例化类
x = MyClass()
# 访问类的属性和方法
print("MyClass 类的属性 i 为：", x.i)
print("MyClass 类的方法 f 输出为：", x.f())
#*以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。
#*执行以上程序输出结果为：
#*MyClass 类的属性 i 为： 12345
#*MyClass 类的方法 f 输出为： hello world
#*类有一个名为 __init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样：
def __init__(self):
    self.data = []
#*类定义了 __init__() 方法，类的实例化操作会自动调用 __init__() 方法。如下实例化类 MyClass，对应的 __init__() 方法就会被调用:
x = MyClass()
#*当然， __init__() 方法可以有参数，参数通过 __init__() 传递到类的实例化操作上。例如:
class Complex:
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart
x = Complex(3.0, -4.5)
print(x.r, x.i)   # 输出结果：3.0 -4.5
#!self代表类的实例，而非类
#*类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。
class Test:
    def prt(self):
        print(self)
        print(self.__class__)
t = Test()
t.prt()
#*从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。
#*self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:
class Test:
    def prt(runoob):
        print(runoob)
        print(runoob.__class__)
t = Test()
t.prt()

# note204:类的方法
#*在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。
#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print("%s 说: 我 %d 岁。" %(self.name,self.age))
# 实例化类
p = people('runoob',10,30)
p.speak()

# note205:继承
#*Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
#*子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。
#*BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:
class DerivedClassName(modname.BaseClassName):
#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print("%s 说: 我 %d 岁。" %(self.name,self.age))
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade))
s = student('ken',10,60,3)
s.speak()

#note206:多继承
#*Python同样有限的支持多继承形式。多继承的类定义形如下例:
class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
#*需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。
#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print("%s 说: 我 %d 岁。" %(self.name,self.age))
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade))
#另一个类，多重继承之前的准备
class speaker():
    topic = ''
    name = ''
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print("我叫 %s，我是一个演说家，我演讲的主题是 %s"%(self.name,self.topic))
#多重继承
class sample(speaker,student):
    a =''
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)
test = sample("Tim",25,80,4,"Python")
test.speak()   #方法名同，默认调用的是在括号中参数位置排前父类的方法

# note207:方法重写
#*如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：
class Parent:        # 定义父类
    def myMethod(self):
        print ('调用父类方法')
class Child(Parent): # 定义子类
    def myMethod(self):
        print ('调用子类方法')
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法
#*super() 函数是用于调用父类(超类)的一个方法。

# note208:类属性与方法
#*类的私有属性
#*__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
#*类的方法
#*在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。
#*self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。
#*类的私有方法
#*__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。
#*实例
#*类的私有属性实例如下：
class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量
    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print (self.__secretCount)
counter = JustCounter()
counter.count()
counter.count()
print (counter.publicCount)
print (counter.__secretCount)  # 报错，实例不能访问私有变量
#*类的私有方法实例如下
class Site:
    def __init__(self, name, url):
        self.name = name       # public
        self.__url = url   # private
    def who(self):
        print('name  : ', self.name)
        print('url : ', self.__url)
    def __foo(self):          # 私有方法
        print('这是私有方法')
    def foo(self):            # 公共方法
        print('这是公共方法')
        self.__foo()
x = Site('菜鸟教程', 'www.runoob.com')
x.who()        # 正常输出
x.foo()        # 正常输出
x.__foo()      # 报错

# note209:类的专有方法
__init__ : 构造函数，在生成对象时调用
__del__ : 析构函数，释放对象时使用
__repr__ : 打印，转换
__setitem__ : 按照索引赋值
__getitem__: 按照索引获取值
__len__: 获得长度
__cmp__: 比较运算
__call__: 函数调用
__add__: 加运算
__sub__: 减运算
__mul__: 乘运算
__truediv__: 除运算
__mod__: 求余运算
__pow__: 乘方

# note210:运算符重载
#*Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下：
class Vector:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def __str__(self):
        return 'Vector (%d, %d)' % (self.a, self.b)
    def __add__(self,other):
        return Vector(self.a + other.a, self.b + other.b)
v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)

# done24:命名空间和作用域
# note211:命名空间
#?命名空间定义
#*命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。
#*命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。
#*举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。
#*一般有三种命名空间：
内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。
全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）
#*命名空间查找顺序:
#*假设我们要使用变量 runoob，则 Python 的查找顺序为：局部的命名空间去 -> 全局命名空间 -> 内置命名空间。
#*如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常:
NameError: name 'runoob' is not defined。
#*命名空间的生命周期：
#*命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。
#*因此，我们无法从外部命名空间访问内部命名空间的对象。
# var1 是全局名称
var1 = 5
def some_func():
    # var2 是局部名称
    var2 = 6
    def some_inner_func():
        # var3 是内嵌的局部名称
        var3 = 7

# note212:作用域
#?作用域定义
#*作用域就是一个 Python 程序可以直接访问命名空间的正文区域。
#*在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。
#*Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。
#*变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有4种，分别是：
L（Local）：最内层，包含局部变量，比如一个函数/方法内部。
E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。
G（Global）：当前脚本的最外层，比如当前模块的全局变量。
B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。
#!注意:规则顺序： L –> E –> G –> B。
#!在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找
g_count = 0  # 全局作用域
def outer():
    o_count = 1  # 闭包函数外的函数中
    def inner():
        i_count = 2  # 局部作用域
#*内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量:
>>> import builtins
>>> dir(builtins)
#*Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：
>>> if True:
...  msg = 'I am from Runoob'
...
>>> msg
'I am from Runoob'
>>>
#*实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。
#*如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：
>>> def test():
...     msg_inner = 'I am from Runoob'
...
>>> msg_inner
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'msg_inner' is not defined
#*从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用

# note213:全局变量与局部变量
#*定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。
#*局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：
total = 0 # 这是一个全局变量
# 可写函数说明
def sum( arg1, arg2 ):
    #返回2个参数的和."
    total = arg1 + arg2 # total在这里是局部变量.
    print ("函数内是局部变量 : ", total)
    return total
#调用sum函数
sum( 10, 20 )
print ("函数外是全局变量 : ", total)

# note214:global和nonlocal关键字
#*当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了。
#*以下实例修改全局变量 num：
num = 1
def fun1():
    global num  # 需要使用 global 关键字声明
    print(num)
    num = 123
    print(num)
fun1()
print(num)
#*如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例
def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
outer()

#!另外有一种特殊情况，假设下面这段代码被运行(会出现报错)：
a = 10
def test():
    a = a + 1
    print(a)
test()
#!错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。
#*修改 a 为全局变量：
a = 10
def test():
    global a
    a = a + 1
    print(a)
test()
#*也可以通过函数参数传递
a = 10
def test(a):
    a = a + 1
    print(a)
test(a)

# done25:Python3 标准库概览
# note215:操作系统接口
#*os模块提供了不少与操作系统相关联的函数。
>>> import os
>>> os.getcwd()      # 返回当前的工作目录
'C:\\Python34'
>>> os.chdir('/server/accesslogs')   # 修改当前的工作目录
>>> os.system('mkdir today')   # 执行系统命令 mkdir 
0
#*建议使用 "import os" 风格而非 "from os import *"。这样可以保证随操作系统不同而有所变化的 os.open() 不会覆盖内置函数 open()。
#*在使用 os 这样的大型模块时内置的 dir() 和 help() 函数非常有用:
>>> import os
>>> dir(os)
<returns a list of all module functions>
>>> help(os)
<returns an extensive manual page created from the module's docstrings>
#*针对日常的文件和目录管理任务，:mod:shutil 模块提供了一个易于使用的高级接口:
>>> import shutil
>>> shutil.copyfile('data.db', 'archive.db')
>>> shutil.move('/build/executables', 'installdir')
# note216:文件通配符
#*glob模块提供了一个函数用于从目录通配符搜索中生成文件列表:
>>> import glob
>>> glob.glob('*.py')
['primes.py', 'random.py', 'quote.py']
# note217:命令行参数
#*通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。例如在命令行中执行 "python demo.py one two three" 后可以得到以下输出结果:
>>> import sys
>>> print(sys.argv)
['demo.py', 'one', 'two', 'three']
# note218:错误输出重定向和程序终止
sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。
>>> sys.stderr.write('Warning, log file not found starting a new one\n')
Warning, log file not found starting a new one
#*大多脚本的定向终止都使用 "sys.exit()"。
# note219:字符串正则匹配
#*re模块为高级字符串处理提供了正则表达式工具。对于复杂的匹配和处理，正则表达式提供了简洁、优化的解决方案:
>>> import re
>>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
['foot', 'fell', 'fastest']
>>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
'cat in the hat'
#*如果只需要简单的功能，应该首先考虑字符串方法，因为它们非常简单，易于阅读和调试:
>>> 'tea for too'.replace('too', 'two')
'tea for two'
# note220:数学
#*math模块为浮点运算提供了对底层C函数库的访问:
>>> import math
>>> math.cos(math.pi / 4)
0.70710678118654757
>>> math.log(1024, 2)
10.0
#*random提供了生成随机数的工具。
>>> import random
>>> random.choice(['apple', 'pear', 'banana'])
'apple'
>>> random.sample(range(100), 10)   # sampling without replacement
[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
>>> random.random()    # random float
0.17970987693706186
>>> random.randrange(6)    # random integer chosen from range(6)
4
# note221:访问互联网
#*有几个模块用于访问互联网以及处理网络通信协议。其中最简单的两个是用于处理从 urls 接收的数据的 urllib.request 以及用于发送电子邮件的 smtplib:
>>> from urllib.request import urlopen
>>> for line in urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):
...     line = line.decode('utf-8')  # Decoding the binary data to text.
...     if 'EST' in line or 'EDT' in line:  # look for Eastern Time
...         print(line)

<BR>Nov. 25, 09:43:32 PM EST

>>> import smtplib
>>> server = smtplib.SMTP('localhost')
>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
... """To: jcaesar@example.org
... From: soothsayer@example.org
...
... Beware the Ides of March.
... """)
>>> server.quit()
#*注意第二个例子需要本地有一个在运行的邮件服务器。
# note222:日期和时间
#*datetime模块为日期和时间处理同时提供了简单和复杂的方法。
#*支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。
#*该模块还支持时区处理:
>>> # dates are easily constructed and formatted
>>> from datetime import date
>>> now = date.today()
>>> now
datetime.date(2003, 12, 2)
>>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'

>>> # dates support calendar arithmetic
>>> birthday = date(1964, 7, 31)
>>> age = now - birthday
>>> age.days
14368
# note223:数据压缩
#*以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile。
>>> import zlib
>>> s = b'witch which has which witches wrist watch'
>>> len(s)
41
>>> t = zlib.compress(s)
>>> len(t)
37
>>> zlib.decompress(t)
b'witch which has which witches wrist watch'
>>> zlib.crc32(s)
226805979
# note224:性能度量
#*有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。
#*例如，使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多,timeit 证明了现代的方法更快一些。
>>> from timeit import Timer
>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
0.57535828626024577
>>> Timer('a,b = b,a', 'a=1; b=2').timeit()
0.54962537085770791
#*相对于 timeit 的细粒度，:mod:profile 和 pstats 模块提供了针对更大代码块的时间度量工具。
# note225:测试模块
#*开发高质量软件的方法之一是为每一个函数开发测试代码，并且在开发过程中经常进行测试
#*doctest模块提供了一个工具，扫描模块并根据程序中内嵌的文档字符串执行测试。
#*测试构造如同简单的将它的输出结果剪切并粘贴到文档字符串中。
#*通过用户提供的例子，它强化了文档，允许 doctest 模块确认代码的结果是否与文档一致:
def average(values):
    """Computes the arithmetic mean of a list of numbers.

    >>> print(average([20, 30, 70]))
    40.0
    """
    return sum(values) / len(values)

import doctest
doctest.testmod()   # 自动验证嵌入测试
unittest模块不像 doctest模块那么容易使用，不过它可以在一个独立的文件里提供一个更全面的测试集:
import unittest

class TestStatisticalFunctions(unittest.TestCase):

    def test_average(self):
        self.assertEqual(average([20, 30, 70]), 40.0)
        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
        self.assertRaises(ZeroDivisionError, average, [])
        self.assertRaises(TypeError, average, 20, 30, 70)

unittest.main() # Calling from the command line invokes all tests

# done26:Python3 正则表达式
# note226:正则表达式介绍
#*正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。
#*Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。
#*re 模块使 Python 语言拥有全部的正则表达式功能。
#*compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。
#*re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。

# note227:rematch函数
#*re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。
#*函数语法：
re.match(pattern, string, flags=0)
#*函数参数说明
参数	    描述
pattern	   匹配的正则表达式
string	   要匹配的字符串。
flags	   标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志
#*匹配成功re.match方法返回一个匹配的对象，否则返回None。
#*我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式
匹配对象方法	    描述
group(num=0)	  匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。
groups()	      返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。
#*实例1
import re
print(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.match('com', 'www.runoob.com'))         # 不在起始位置匹配
#*实例2
import re
line = "Cats are smarter than dogs"
# .* 表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符
# (.*?) 表示"非贪婪"模式，只保存第一个匹配到的子串
matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)
if matchObj:
    print ("matchObj.group() : ", matchObj.group())
    print ("matchObj.group(1) : ", matchObj.group(1))
    print ("matchObj.group(2) : ", matchObj.group(2))
else:
    print ("No match!!")

"
# note228:re.search方法
#*re.search 扫描整个字符串并返回第一个成功的匹配。
#*函数语法：
re.search(pattern, string, flags=0)
#*函数参数使用说明
参数	    描述
pattern	   匹配的正则表达式
string	   要匹配的字符串。
flags	   标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。
#*匹配成功re.search方法返回一个匹配的对象，否则返回None。
#*我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式
匹配对象方法	  描述
group(num=0)	匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。
groups()	    返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。
#*实例
import re
print(re.search('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.search('com', 'www.runoob.com').span())         # 不在起始位置匹配

# note229:re.match与re.search的区别
re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。
#*实例
import re
line = "Cats are smarter than dogs"
matchObj = re.match( r'dogs', line, re.M|re.I)
if matchObj:
    print ("match --> matchObj.group() : ", matchObj.group())
else:
    print ("No match!!")
matchObj = re.search( r'dogs', line, re.M|re.I)
if matchObj:
    print ("search --> matchObj.group() : ", matchObj.group())
else:
    print ("No match!!")

"

# note230:检索和替换
#*Python 的re模块提供了re.sub用于替换字符串中的匹配项。
#*语法：
re.sub(pattern, repl, string, count=0, flags=0)
#*参数：
#*pattern : 正则中的模式字符串。
#*repl : 替换的字符串，也可为一个函数。
#*string : 要被查找替换的原始字符串。
#*count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。
#*flags : 编译时用的匹配模式，数字形式。
#!前三个为必选参数，后两个为可选参数。
import re
phone = "2004-959-559 # 这是一个电话号码"
# 删除注释
num = re.sub(r'#.*$', "", phone)
print ("电话号码 : ", num)
# 移除非数字的内容
num = re.sub(r'\D', "", phone)
print ("电话号码 : ", num)
#!当repl参数为一个函数的时候
#*以下实例中将字符串中的匹配的数字乘以 2：
import re
# 将匹配的数字乘以 2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)
s = 'A23G4HFD567'
print(re.sub('(?P<value>\d+)', double, s))

# note231:compile 函数
#*compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。
#*语法格式为：
re.compile(pattern[, flags])
#*参数
#*pattern : 一个字符串形式的正则表达式
#*flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：
#*re.I 忽略大小写
#*re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境
#*re.M 多行模式
#*re.S 即为' . '并且包括换行符在内的任意字符（' . '不包括换行符）
#*re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库
#*re.X 为了增加可读性，忽略空格和' # '后面的注释
import re
pattern = re.compile(r'\d+')                    # 用于匹配至少一个数字
m = pattern.match('one12twothree34four')        # 查找头部，没有匹配
print( m )
m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配
print( m )
m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配
print( m )                                        # 返回一个 Match 对象
m.group(0)   # 可省略 0
m.start(0)   # 可省略 0
m.end(0)     # 可省略 0
m.span(0)    # 可省略 0
#*在上面，当匹配成功时返回一个 Match 对象，其中：
#*group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；
#*start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；
#*end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；
#*span([group]) 方法返回 (start(group), end(group))。

# note232:findall
#*在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。
#!注意： match 和 search 是匹配一次 findall 匹配所有。
#*语法格式为：
re.findall(pattern, string, flags=0)
#!更多时候re.findall只使用两个参数:re.findall("匹配条件", 带匹配数据)
或
pattern.findall(string[, pos[, endpos]])
#*参数：
#*pattern 匹配模式。
#*string 待匹配的字符串。
#*pos 可选参数，指定字符串的起始位置，默认为 0。
#*endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。
#*查找字符串中的所有数字：
import re
result1 = re.findall(r'\d+','runoob 123 google 456')
pattern = re.compile(r'\d+')   # 查找数字
result2 = pattern.findall('runoob 123 google 456')
result3 = pattern.findall('run88oob123google456', 0, 10)
print(result1)
print(result2)
print(result3)
#*多个匹配模式，返回元组列表：
import re
result = re.findall(r'(\w+)=(\d+)', 'set width=20 and height=10')
print(result)

# note233:re.finditer
#*和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。
re.finditer(pattern, string, flags=0)
#*参数：
参数	    描述
pattern	   匹配的正则表达式
string	   要匹配的字符串。
flags	   标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等
import re
it = re.finditer(r"\d+","12a32bc43jf3")
for match in it:
    print (match.group() )

# note234:re.split
#*split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：
re.split(pattern, string[, maxsplit=0, flags=0])
#*参数
参数	    描述
pattern	   匹配的正则表达式
string	   要匹配的字符串。
maxsplit   分割次数，maxsplit=1 分割一次，默认为 0，不限制次数。
flags	   标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等
#*实例(将一个完整的字符串按照一个个字母进行拆分)
import re
re.split('\W+', 'runoob, runoob, runoob.')
re.split('(\W+)', ' runoob, runoob, runoob.')
re.split('\W+', ' runoob, runoob, runoob.', 1)
re.split('a*', 'hello world')   # 对于一个找不到匹配的字符串而言，split 不会对其作出分割

# note235:正则表达式对象
#*re.RegexObject
#*re.compile() 返回 RegexObject 对象。
#*re.MatchObject
#*group() 返回被 RE 匹配的字符串。
#*start() 返回匹配开始的位置
#*end() 返回匹配结束的位置
#*span() 返回一个元组包含匹配 (开始,结束) 的位置

# note236:正则表达式修饰符——可选标志
#*正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：
修饰符	 描述
re.I	使匹配对大小写不敏感
re.L	做本地化识别（locale-aware）匹配
re.M	多行匹配，影响 ^ 和 $
re.S	使 . 匹配包括换行在内的所有字符
re.U	根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.
re.X	该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。

# note237:正则表达式模式
#*模式字符串使用特殊的语法来表示一个正则表达式。
#*字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。
#*多数字母和数字前加一个反斜杠时会拥有不同的含义。
#*标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。
#*反斜杠本身需要使用反斜杠转义。
#*由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\t'，等价于 \\t )匹配相应的特殊字符。
#*下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。
模式	        描述
^	           匹配字符串的开头
$	           匹配字符串的末尾。
.	           匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。
[...]	       用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
[^...]	       不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
re*	           匹配0个或多个的表达式。
re+	           匹配1个或多个的表达式。
re?	           匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
re{ n}	       匹配n个前面表达式。例如，"o{2}"不能匹配"Bob"中的"o"，但是能匹配"food"中的两个o。
re{ n,}	       精确匹配n个前面表达式。例如，"o{2,}"不能匹配"Bob"中的"o"，但能匹配"foooood"中的所有o。"o{1,}"等价于"o+"。"o{0,}"则等价于"o*"。
re{ n, m}      匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
a| b	       匹配a或b
(re)	       匹配括号内的表达式，也表示一个组
(?imx)	       正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
(?-imx)	       正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
(?: re)	       类似 (...), 但是不表示一个组
(?imx: re)	   在括号中使用i, m, 或 x 可选标志
(?-imx: re)	   在括号中不使用i, m, 或 x 可选标志
(?#...)	       注释.
(?= re)	       前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
(?! re)	       前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。
(?> re)	       匹配的独立模式，省去回溯。
\w	           匹配数字字母下划线
\W	           匹配非数字字母下划线
\s	           匹配任意空白字符，等价于 [\t\n\r\f]。
\S	           匹配任意非空字符
\d	           匹配任意数字，等价于 [0-9]。
\D	           匹配任意非数字
\A	           匹配字符串开始
\Z	           匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。
\z	           匹配字符串结束
\G	           匹配最后匹配完成的位置。
\b	           匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
\B	           匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
\n, \t, 等。    匹配一个换行符。匹配一个制表符, 等
\1...\9	       匹配第n个分组的内容。
\10	           匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。

# note238:正则表达式实例
#*字符匹配
实例	    描述
python	    匹配 "python".
#*字符类
实例	     描述
[Pp]ython	匹配 "Python" 或 "python"
rub[ye]	    匹配 "ruby" 或 "rube"
[aeiou]	    匹配中括号内的任意一个字母
[0-9]	    匹配任何数字。类似于 [0123456789]
[a-z]	    匹配任何小写字母
[A-Z]	    匹配任何大写字母
[a-zA-Z0-9]	匹配任何字母及数字
[^aeiou]	除了aeiou字母以外的所有字符
[^0-9]	    匹配除了数字外的字符
#*特殊字符类
实例	    描述
.	       匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。
\d	       匹配一个数字字符。等价于 [0-9]。
\D	       匹配一个非数字字符。等价于 [^0-9]。
\s	       匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S	       匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\w	       匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
\W	       匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。

# done27:MySQL - mysql-connector 驱动(主要为mysql数据库使用)
#*与C#与VBA均类似，在引号中写入mysql或者是sql server语句
# note239:创建数据库连接
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",       # 数据库主机地址
    user="yourusername",    # 数据库用户名
    passwd="yourpassword"   # 数据库密码
)
print(mydb)

# note240:创建数据库
#*创建数据库使用 "CREATE DATABASE" 语句，以下创建一个名为 runoob_db 的数据库：
demo_mysql_test.py:
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456"
)
mycursor = mydb.cursor()
mycursor.execute("CREATE DATABASE runoob_db")
#!创建数据库前最好使用show database检查是否存在目标数据库
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456"
)
mycursor = mydb.cursor()
mycursor.execute("SHOW DATABASES") #*检查数据库是否存在
for x in mycursor:
    print(x)
#*或者直接连接数据库信息，如果没有该数据库直接显示报错
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)

# note241:主键设置
#*创建表的时候我们一般都会设置一个主键（PRIMARY KEY），我们可以使用 "INT AUTO_INCREMENT PRIMARY KEY" 语句来创建一个主键，主键起始值为 1，逐步递增。
#*如果我们的表已经创建，我们需要使用 ALTER TABLE 来给表添加主键：
#*一下实例中将给 sites 表添加主键。
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
mycursor.execute("ALTER TABLE sites ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY")
#*如果还没有创建sites表，可以先创建数据表
#*给表创建主键
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
mycursor.execute("CREATE TABLE sites (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), url VARCHAR(255))")

"

# note242:插入数据
#*插入数据使用 "INSERT INTO" 语句：
#*向 sites 表插入一条记录。
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",       #*地址
    user="root",            #*用户名
    passwd="123456",        #*密码
    database="runoob_db"    #*数据库名称
)
mycursor = mydb.cursor()
sql = "INSERT INTO sites (name, url) VALUES (%s, %s)"
val = ("RUNOOB", "https://www.runoob.com")
mycursor.execute(sql, val)
mydb.commit()    # 数据表内容有更新，必须使用到该语句
print(mycursor.rowcount, "记录插入成功。")

# note243:批量插入
#*批量插入使用 executemany() 方法，该方法的第二个参数是一个元组列表，包含了我们要插入的数据：
#*向 sites 表插入多条记录。
import mysql.connector
#*输入数据库信息
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
#*批量插入新列
sql = "INSERT INTO sites (name, url) VALUES (%s, %s)"
val = [
    ('Google', 'https://www.google.com'),
    ('Github', 'https://www.github.com'),
    ('Taobao', 'https://www.taobao.com'),
    ('stackoverflow', 'https://www.stackoverflow.com/')
]
mycursor.executemany(sql, val)
mydb.commit()    # 数据表内容有更新，必须使用到该语句
print(mycursor.rowcount, "记录插入成功。")
#*如果想在数据记录插入后，获取该记录的 ID ，可以使用以下代码
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "INSERT INTO sites (name, url) VALUES (%s, %s)"
val = ("Zhihu", "https://www.zhihu.com")
mycursor.execute(sql, val)
mydb.commit()
print("1 条记录已插入, ID:", mycursor.lastrowid)

# note244:查询数据
#*使用select语句进行查询
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
#*查询数据库中数据
#?为什么执行sql语句不使用sql =
mycursor.execute("SELECT * FROM sites")
myresult = mycursor.fetchall()     # fetchall() 获取所有记录
for x in myresult:
    print(x)
#*以下代码读取指定字段数据
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
mycursor.execute("SELECT name, url FROM sites")
myresult = mycursor.fetchall()
for x in myresult:
    print(x)
#*如果只读取一条数据时候，使用fetchone() 方法
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
mycursor.execute("SELECT * FROM sites")
myresult = mycursor.fetchone()
print(myresult)

# note245:where条件语句
#*读取 name 字段为 RUNOOB 的记录
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "SELECT * FROM sites WHERE name ='RUNOOB'"
mycursor.execute(sql)
myresult = mycursor.fetchall()
for x in myresult:
    print(x)
#*也可以使用通配符 %
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "SELECT * FROM sites WHERE url LIKE '%oo%'"
mycursor.execute(sql)
myresult = mycursor.fetchall()
for x in myresult:
    print(x)
#*为了防止数据库查询发生 SQL 注入的攻击，我们可以使用 %s 占位符来转义查询的条件
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "SELECT * FROM sites WHERE name = %s"
na = ("RUNOOB", )
mycursor.execute(sql, na)
myresult = mycursor.fetchall()
for x in myresult:
    print(x)

# note246:排序
#*查询结果排序可以使用 ORDER BY 语句，
#*默认的排序方式为升序，关键字为 ASC，如果要设置降序排序，可以设置关键字 DESC
#*以下案例按照name字母升序排列
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "SELECT * FROM sites ORDER BY name"
mycursor.execute(sql)
myresult = mycursor.fetchall()
for x in myresult:
    print(x)
#*按照name字段降序排列
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "SELECT * FROM sites ORDER BY name DESC"
mycursor.execute(sql)
myresult = mycursor.fetchall()
for x in myresult:
    print(x)

# note247:Limit
#*如果我们要设置查询的数据量，可以通过 "LIMIT" 语句来指定
#*只读取前三条记录
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
mycursor.execute("SELECT * FROM sites LIMIT 3")
myresult = mycursor.fetchall()
for x in myresult:
    print(x)
#*也可以指定起始位置，使用的关键字是 OFFSET
#*从第二条开始读取前三条记录
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
mycursor.execute("SELECT * FROM sites LIMIT 3 OFFSET 1")  # 0 为 第一条，1 为第二条，以此类推
myresult = mycursor.fetchall()
for x in myresult:
    print(x)

# note248:删除记录
#*除记录使用 "DELETE FROM" 语句：
#*删除 name 为 stackoverflow 的记录：
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "DELETE FROM sites WHERE name = 'stackoverflow'"
mycursor.execute(sql)
mydb.commit()
print(mycursor.rowcount, " 条记录删除")
#!注意：要慎重使用删除语句，删除语句要确保指定了 WHERE 条件语句，否则会导致整表数据被删除。
#!为了防止数据库查询发生 SQL 注入的攻击，我们可以使用 %s 占位符来转义删除语句的条件：
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "DELETE FROM sites WHERE name = %s"
na = ("stackoverflow", )
mycursor.execute(sql, na)
mydb.commit()
print(mycursor.rowcount, " 条记录删除")

# 更新表数据
#*数据表更新使用 "UPDATE" 语句：
#*将 name 为 Zhihu 的字段数据改为 ZH：
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "UPDATE sites SET name = 'ZH' WHERE name = 'Zhihu'"
mycursor.execute(sql)
mydb.commit()
print(mycursor.rowcount, " 条记录被修改")
#!注意：UPDATE 语句要确保指定了 WHERE 条件语句，否则会导致整表数据被更新。
#!为了防止数据库查询发生 SQL 注入的攻击，我们可以使用 %s 占位符来转义更新语句的条件：
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "UPDATE sites SET name = %s WHERE name = %s"
val = ("Zhihu", "ZH")
mycursor.execute(sql, val)
mydb.commit()
print(mycursor.rowcount, " 条记录被修改")

# note249:删除表
#*删除表使用 "DROP TABLE" 语句， IF EXISTS 关键字是用于判断表是否存在，只有在存在的情况才删除
import mysql.connector
mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="123456",
    database="runoob_db"
)
mycursor = mydb.cursor()
sql = "DROP TABLE IF EXISTS sites"  # 删除数据表 sites
mycursor.execute(sql)

# done28:多线程
# note250:多线程介绍
#*多线程类似于同时执行多个不同程序，多线程运行有如下优点：
#*使用线程可以把占据长时间的程序中的任务放到后台去处理。
#*用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。
#*程序的运行速度可能加快。
#*在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。
#*每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
#*每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。
#*指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。
#*线程可以被抢占（中断）。
#*在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） -- 这就是线程的退让。
#*线程可以分为:
#*内核线程：由操作系统内核创建和撤销。
#*用户线程：不需要内核支持而在用户程序中实现的线程。
#*Python3 线程中常用的两个模块为：
#*_thread
#*threading(推荐使用)
#!thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用"thread" 模块。为了兼容性，Python3 将 thread 重命名为 "_thread"。

# note251:python线程
#*Python中使用线程有两种方式：函数或者用类来包装线程对象。
#*函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下:
_thread.start_new_thread ( function, args[, kwargs] )
#*参数说明:
function - 线程函数。
args - 传递给线程函数的参数,他必须是个tuple类型。
kwargs - 可选参数。
#*实例
#!这个程序如果不手动终止，程序会一直往后运行
import _thread
import time

# 为线程定义一个函数


def print_time(threadName, delay):
    count = 0
    while count < 5:
        time.sleep(delay)
        count += 1
        print("%s: %s" % (threadName, time.ctime(time.time())))


# 创建两个线程
try:
    _thread.start_new_thread(print_time, ("Thread-1", 2, ))
    _thread.start_new_thread(print_time, ("Thread-2", 4, ))
except:
    print("Error: 无法启动线程")

while 1:
    pass

# note252:线程模块(_thread 和 threading)
#*Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。
#*_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。
#*threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：
#*threading.currentThread(): 返回当前的线程变量。
#*threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
#*threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。
#*除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:
#*run(): 用以表示线程活动的方法。
#*start():启动线程活动。
#*join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。
#*isAlive(): 返回线程是否活动的。
#*getName(): 返回线程名。
#*setName(): 设置线程名。

# note253:使用 threading 模块创建线程
#*我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：
import threading
import time

exitFlag = 0


class myThread (threading.Thread):
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = delay

    def run(self):
        print("开始线程：" + self.name)
        print_time(self.name, self.delay, 5)
        print("退出线程：" + self.name)


def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            threadName.exit()
        time.sleep(delay)
        print("%s: %s" % (threadName, time.ctime(time.time())))
        counter -= 1


# 创建新线程
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# 开启新线程
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print("退出主线程")

#*线程同步
#*如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。
#*使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：
#*多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。
#*考虑这样一种情况：一个列表里所有元素都是0，线程"set"从后向前把所有元素改成1，而线程"print"负责从前往后读取列表并打印。
#*那么，可能线程"set"开始改的时候，线程"print"便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。
#*锁有两种状态——锁定和未锁定。每当一个线程比如"set"要访问共享数据时，必须先获得锁定；如果已经有别的线程比如"print"获得锁定了，那么就让线程"set"暂停，也就是同步阻塞；等到线程"print"访问完毕，释放锁以后，再让线程"set"继续。
#*经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。
#*实例
import threading
import time


class myThread (threading.Thread):
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = delay

    def run(self):
        print("开启线程： " + self.name)
        # 获取锁，用于线程同步
        threadLock.acquire()
        print_time(self.name, self.delay, 3)
        # 释放锁，开启下一个线程
        threadLock.release()


def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        print("%s: %s" % (threadName, time.ctime(time.time())))
        counter -= 1


threadLock = threading.Lock()
threads = []

# 创建新线程
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# 开启新线程
thread1.start()
thread2.start()

# 添加线程到线程列表
threads.append(thread1)
threads.append(thread2)

# 等待所有线程完成
for t in threads:
    t.join()
print("退出主线程")

#*线程优先级队列（ Queue）
#*Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。
#*这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。
#*Queue 模块中的常用方法:
#*Queue.qsize() 返回队列的大小
#*Queue.empty() 如果队列为空，返回True,反之False
#*Queue.full() 如果队列满了，返回True,反之False
#*Queue.full 与 maxsize 大小对应
#*Queue.get([block[, timeout]])获取队列，timeout等待时间
#*Queue.get_nowait() 相当Queue.get(False)
#*Queue.put(item) 写入队列，timeout等待时间
#*Queue.put_nowait(item) 相当Queue.put(item, False)
#*Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号
#*Queue.join() 实际上意味着等到队列为空，再执行别的操作
#*实例
import queue
import threading
import time

exitFlag = 0


class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q

    def run(self):
        print("开启线程：" + self.name)
        process_data(self.name, self.q)
        print("退出线程：" + self.name)


def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print("%s processing %s" % (threadName, data))
        else:
            queueLock.release()
        time.sleep(1)


threadList = ["Thread-1", "Thread-2", "Thread-3"]
nameList = ["One", "Two", "Three", "Four", "Five"]
queueLock = threading.Lock()
workQueue = queue.Queue(10)
threads = []
threadID = 1

# 创建新线程
for tName in threadList:
    thread = myThread(threadID, tName, workQueue)
    thread.start()
    threads.append(thread)
    threadID += 1

# 填充队列
queueLock.acquire()
for word in nameList:
    workQueue.put(word)
queueLock.release()

# 等待队列清空
while not workQueue.empty():
    pass

# 通知线程是时候退出
exitFlag = 1

# 等待所有线程完成
for t in threads:
    t.join()
print("退出主线程")

# done29:urllib(抓取数据)
# note254:urllib包介绍
#*Python urllib 库用于操作网页 URL，并对网页的内容进行抓取处理。
#*本文主要介绍 Python3 的 urllib。
#*urllib 包 包含以下几个模块：
#*urllib.request - 打开和读取 URL。
#*urllib.error - 包含 urllib.request 抛出的异常。
#*urllib.parse - 解析 URL。
#*urllib.robotparser - 解析 robots.txt 文件。

# note255:urllib.request
#*urllib.request 定义了一些打开 URL 的函数和类，包含授权验证、重定向、浏览器 cookies等。
#*urllib.request 可以模拟浏览器的一个请求发起过程。
#*我们可以使用 urllib.request 的 urlopen 方法来打开一个 URL，语法格式如下：
urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)
#*url：url 地址。
#*data：发送到服务器的其他数据对象，默认为 None。
#*timeout：设置访问超时时间。
#*cafile 和 capath：cafile 为 CA 证书， capath 为 CA 证书的路径，使用 HTTPS 需要用到。
#*cadefault：已经被弃用。
#*context：ssl.SSLContext类型，用来指定 SSL 设置。
#*实例:以下代码中使用 urlopen 打开一个 URL，然后使用 read() 函数获取网页的 HTML 实体代码
from urllib.request import urlopen

myURL = urlopen("https://www.runoob.com/")
print(myURL.read())

# note256:read() 是读取整个网页内容，我们可以指定读取的长度：
from urllib.request import urlopen

myURL = urlopen("https://www.runoob.com/")
print(myURL.read(300))

#*除了 read() 函数外，还包含以下两个读取网页内容的函数：
readline() - 读取文件的一行内容
from urllib.request import urlopen

myURL = urlopen("https://www.runoob.com/")
print(myURL.readline()) #读取一行内容

#*readlines() - 读取文件的全部内容，它会把读取的内容赋值给一个列表变量。
from urllib.request import urlopen

myURL = urlopen("https://www.runoob.com/")
lines = myURL.readlines()
for line in lines:
    print(line)

#!注意:我们在对网页进行抓取时，经常需要判断网页是否可以正常访问，这里我们就可以使用 getcode() 函数获取网页状态码，返回 200 说明网页正常，返回 404 说明网页不存在:
#*实例
import urllib.request

myURL1 = urllib.request.urlopen("https://www.runoob.com/")
print(myURL1.getcode())   # 200

try:
    myURL2 = urllib.request.urlopen("https://www.runoob.com/no.html") #*无法打开网页
except urllib.error.HTTPError as e:
    if e.code == 404:
        print(404)   # 404
    else:
        print(200)

#*如果想将抓取的网页保存在本地(就在脚本文件所在的文件夹中)
from urllib.request import urlopen

myURL = urlopen("https://www.runoob.com/")
f = open("runoob_urllib_test.html", "wb")
content = myURL.read()  # 读取网页内容
f.write(content)
f.close()

#*URL 的编码与解码可以使用 urllib.request.quote() 与 urllib.request.unquote() 方法：
#*实例
import urllib.request

encode_url = urllib.request.quote("https://www.runoob.com/")  # 编码
print(encode_url)

unencode_url = urllib.request.unquote(encode_url)    # 解码
print(unencode_url)

#*模拟头部信息
#*我们抓取网页一般需要对 headers（网页头信息）进行模拟，这时候需要使用到 urllib.request.Request 类：
#*class urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)
#*url：url 地址。
#*data：发送到服务器的其他数据对象，默认为 None。
#*headers：HTTP 请求的头部信息，字典格式。
#*origin_req_host：请求的主机地址，IP 或域名。
#*unverifiable：很少用整个参数，用于设置网页是否需要验证，默认是False。。
#*method：请求方法， 如 GET、POST、DELETE、PUT等。
import urllib.request
import urllib.parse

url = 'https://www.runoob.com/?s='  # 菜鸟教程搜索页面
keyword = 'Python 教程'
key_code = urllib.request.quote(keyword)  # 对请求进行编码
url_all = url+key_code
header = {
    'User-Agent':'Mozilla/5.0 (X11; Fedora; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'
}   #头部信息
request = urllib.request.Request(url_all,headers=header)
reponse = urllib.request.urlopen(request).read()

fh = open("./urllib_test_runoob_search.html","wb")    # 将文件写入到当前目录中
fh.write(reponse)
fh.close()

#*表单 POST 传递数据，我们先创建一个表单，代码如下，我这里使用了 PHP 代码来获取表单的数据
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com) urllib POST  测试</title>
</head>
<body>
<form action="" method="post" name="myForm">
    Name: <input type="text" name="name"><br>
    Tag: <input type="text" name="tag"><br>
    <input type="submit" value="提交">
</form>
<hr>
<?php
// 使用 PHP 来获取表单提交的数据，你可以换成其他的
if(isset($_POST['name']) && $_POST['tag'] ) {
    echo $_POST["name"] . ', ' . $_POST['tag'];
}
?>
</body>
</html>
#*实例
import urllib.request
import urllib.parse

url = 'https://www.runoob.com/try/py3/py3_urllib_test.php'  # 提交到表单页面
data = {'name':'RUNOOB', 'tag' : '账号'}   # 提交数据
header = {
    'User-Agent':'Mozilla/5.0 (X11; Fedora; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'
}   #头部信息
data = urllib.parse.urlencode(data).encode('utf8')  # 对参数进行编码，解码使用 urllib.parse.urldecode
request=urllib.request.Request(url, data, header)   # 请求处理
reponse=urllib.request.urlopen(request).read()      # 读取结果

fh = open("./urllib_test_post_runoob.html","wb")    # 将文件写入到当前目录中
fh.write(reponse)
fh.close()

# note257:urllib.error
#*urllib.error 模块为 urllib.request 所引发的异常定义了异常类，基础异常类是 URLError。
#*urllib.error 包含了两个方法，URLError 和 HTTPError。
#*URLError 是 OSError 的一个子类，用于处理程序在遇到问题时会引发此异常（或其派生的异常），包含的属性 reason 为引发异常的原因。
#*HTTPError 是 URLError 的一个子类，用于处理特殊 HTTP 错误例如作为认证请求的时候，包含的属性 code 为 HTTP 的状态码， reason 为引发异常的原因，headers 为导致 HTTPError 的特定 HTTP 请求的 HTTP 响应头。
#*对不存在的网页抓取并处理异常:
import urllib.request
import urllib.error

myURL1 = urllib.request.urlopen("https://www.runoob.com/")
print(myURL1.getcode())   # 200

try:
    myURL2 = urllib.request.urlopen("https://www.runoob.com/no.html")
except urllib.error.HTTPError as e:
    if e.code == 404:
        print(404)   # 404

# note258:urllib.parse
#*urllib.parse 用于解析 URL，格式如下：
urllib.parse.urlparse(urlstring, scheme='', allow_fragments=True)
#*urlstring 为 字符串的 url 地址，scheme 为协议类型，
#*allow_fragments 参数为 false，则无法识别片段标识符。
#*相反，它们被解析为路径，参数或查询组件的一部分，并 fragment 在返回值中设置为空字符串。
from urllib.parse import urlparse

o = urlparse("https://www.runoob.com/?s=python+%E6%95%99%E7%A8%8B")
print(o)
#*从结果可以看出，内容是一个元组，包含 6 个字符串：协议，位置，路径，参数，查询，判断。
#*以直接读取协议内容
from urllib.parse import urlparse

o = urlparse("https://www.baidu.com")
print(o.scheme)

# note259:urllib.robotparser
#*urllib.robotparser 用于解析 robots.txt 文件。
#*robots.txt（统一小写）是一种存放于网站根目录下的 robots 协议，它通常用于告诉搜索引擎对网站的抓取规则。
#*urllib.robotparser 提供了 RobotFileParser 类，语法如下：
#*class urllib.robotparser.RobotFileParser(url='')

#*这个类提供了一些可以读取、解析 robots.txt 文件的方法：
#*set_url(url) - 设置 robots.txt 文件的 URL。
#*read() - 读取 robots.txt URL 并将其输入解析器。
#*parse(lines) - 解析行参数。
#*can_fetch(useragent, url) - 如果允许 useragent 按照被解析 robots.txt 文件中的规则来获取 url 则返回 True。
#*mtime() -返回最近一次获取 robots.txt 文件的时间。 这适用于需要定期检查 robots.txt 文件更新情况的长时间运行的网页爬虫。
#*modified() - 将最近一次获取 robots.txt 文件的时间设置为当前时间。
#*crawl_delay(useragent) -为指定的 useragent 从 robots.txt 返回 Crawl-delay 形参。 如果此形参不存在或不适用于指定的 useragent 或者此形参的 robots.txt 条目存在语法错误，则返回 None。
#*request_rate(useragent) -以 named tuple RequestRate(requests, seconds) 的形式从 robots.txt 返回 Request-rate 形参的内容。 如果此形参不存在或不适用于指定的 useragent 或者此形参的 robots.txt 条目存在语法错误，则返回 None。
#*site_maps() - 以 list() 的形式从 robots.txt 返回 Sitemap 形参的内容。 如果此形参不存在或者此形参的 robots.txt 条目存在语法错误，则返回 None。
#*实例
import urllib.robotparser
rp = urllib.robotparser.RobotFileParser()
rp.set_url("http://www.musi-cal.com/robots.txt")
rp.read()
rrate = rp.request_rate("*")
rrate.requests
rrate.seconds
rp.crawl_delay("*")
rp.can_fetch("*", "http://www.musi-cal.com/cgi-bin/search?city=San+Francisco")
rp.can_fetch("*", "http://www.musi-cal.com/")

# done30:operator 模块(比较两列表大小)
# note260:operator使用
#*operator 模块来比较两个列表、数字或字符串等的大小关系，适合任何对象，包含的方法有：
operator.lt(a, b)
operator.le(a, b)
operator.eq(a, b)
operator.ne(a, b)
operator.ge(a, b)
operator.gt(a, b)
operator.__lt__(a, b)
operator.__le__(a, b)
operator.__eq__(a, b)
operator.__ne__(a, b)
operator.__ge__(a, b)
operator.__gt__(a, b)
#*operator.lt(a, b) 与 a < b 相同， operator.le(a, b) 与 a <= b 相同，operator.eq(a, b) 与 a == b 相同，
#*operator.ne(a, b) 与 a != b 相同，operator.gt(a, b) 与 a > b 相同，operator.ge(a, b) 与 a >= b 相同。
#*实例
import operator
# 数字
x = 10
y = 20

print("x:",x, ", y:",y)
print("operator.lt(x,y): ", operator.lt(x,y))
print("operator.gt(y,x): ", operator.gt(y,x))
print("operator.eq(x,y): ", operator.eq(x,y))
print("operator.ne(x,y): ", operator.ne(x,y))
print("operator.le(x,y): ", operator.le(x,y))
print("operator.ge(y,x): ", operator.ge(y,x))
print()

# 字符串
x = "Google"
y = "Runoob"

print("x:",x, ", y:",y)
print("operator.lt(x,y): ", operator.lt(x,y))
print("operator.gt(y,x): ", operator.gt(y,x))
print("operator.eq(x,y): ", operator.eq(x,y))
print("operator.ne(x,y): ", operator.ne(x,y))
print("operator.le(x,y): ", operator.le(x,y))
print("operator.ge(y,x): ", operator.ge(y,x))
print()

# 查看返回值
print("type((operator.lt(x,y)): ", type(operator.lt(x,y)))

"

#*比较两个列表
import operator

a = [1, 2]
b = [2, 3]
c = [2, 3]
print("operator.eq(a,b): ", operator.eq(a,b))
print("operator.eq(c,b): ", operator.eq(c,b))

"

# note261:运算符函数
#*operator 模块提供了一套与 Python 的内置运算符对应的高效率函数。例如，operator.add(x, y) 与表达式 x+y 相同。
#*函数包含的种类有：对象的比较运算、逻辑运算、数学运算以及序列运算。
#*对象比较函数适用于所有的对象，函数名根据它们对应的比较运算符命名。
#*许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数，为了表述清楚，建议使用没有双下划线的函数。
import operator
# 初始化变量
a = 4
b = 3
# 使用 add() 让两个值相加
print ("add() 运算结果 :",end="");
print (operator.add(a, b))
# 使用 sub() 让两个值相减
print ("sub() 运算结果 :",end="");
print (operator.sub(a, b))
# 使用 mul() 让两个值相乘
print ("mul() 运算结果 :",end="");
print (operator.mul(a, b))

"

# done31:requests 模块
#*Python 内置了 requests 模块，该模块主要用来发 送 HTTP 请求，requests 模块比 urllib 模块更简洁。
# 导入 requests 包
import requests

# 发送请求
x = requests.get('https://www.baidu.com')

# 返回网页内容
print(x.text)
#*每次调用 requests 请求之后，会返回一个 response 对象，该对象包含了具体的响应信息。
#*响应信息如下：
属性或方法	                            说明
apparent_encoding	                  编码方式
close()	                              关闭与服务器的连接
content	                              返回响应的内容，以字节为单位
cookies	                              返回一个 CookieJar 对象，包含了从服务器发回的 cookie
elapsed	                              返回一个 timedelta 对象，包含了从发送请求到响应到达之间经过的时间量，可以用于测试响应速度。比如 r.elapsed.microseconds 表示响应到达需要多少微秒。
encoding	                          解码 r.text 的编码方式
headers	                              返回响应头，字典格式
history	                              返回包含请求历史的响应对象列表（url）
is_permanent_redirect	              如果响应是永久重定向的 url，则返回 True，否则返回 False
is_redirect	                          如果响应被重定向，则返回 True，否则返回 False
iter_content()	                      迭代响应
iter_lines()	                      迭代响应的行
json()	                              返回结果的 JSON 对象 (结果需要以 JSON 格式编写的，否则会引发错误)
links	                              返回响应的解析头链接
next	                              返回重定向链中下一个请求的 PreparedRequest 对象
ok	                                  检查 "status_code" 的值，如果小于400，则返回 True，如果不小于 400，则返回 False
raise_for_status()	                  如果发生错误，方法返回一个 HTTPError 对象
reason	                              响应状态的描述，比如 "Not Found" 或 "OK"
request	                              返回请求此响应的请求对象
status_code	                          返回 http 的状态码，比如 404 和 200（200 是 OK，404 是 Not Found）
text	                              返回响应的内容，unicode 类型数据
url	                                  返回响应的 URL

#*实例
import requests

# 发送请求
x = requests.get('https://www.runoob.com/')

# 返回 http 的状态码
print(x.status_code)

# 响应状态的描述
print(x.reason)

# 返回编码
print(x.apparent_encoding)

#*请求 json 数据文件，返回 json 内容：
#*实例
# 导入 requests 包
import requests

# 发送请求
x = requests.get('https://www.baidu.com')

# 返回 json 数据
print(x.json())

# note262:request方法

方法	                        描述
delete(url, args)	           发送 DELETE 请求到指定 url
get(url, params, args)	       发送 GET 请求到指定 url
head(url, args)	               发送 HEAD 请求到指定 url
patch(url, data, args)	       发送 PATCH 请求到指定 url
post(url, data, json, args)	   发送 POST 请求到指定 url
put(url, data, args)	       发送 PUT 请求到指定 url
request(method, url, args)	   向指定的 url 发送指定的请求方法

#*使用 requests.request() 发送 get 请求：
#*实例
# 导入 requests 包
import requests

# 发送请求
x = requests.request('get', 'https://www.runoob.com/')

# 返回网页内容
print(x.status_code)

#*设置请求头：
实例
# 导入 requests 包
import requests

kw = {'s':'python 教程'}

# 设置请求头
headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36"}
# params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()
response = requests.get("https://www.runoob.com/", params = kw, headers = headers)

# 查看响应状态码
print (response.status_code)

# 查看响应头部字符编码
print (response.encoding)

# 查看完整url地址
print (response.url)

# 查看响应内容，response.text 返回的是Unicode格式的数据
print(response.text)

#*post() 方法可以发送 POST 请求到指定 url，一般格式如下：
requests.post(url, data={key: value}, json={key: value}, args)
#*url 请求 url。
#*data 参数为要发送到指定 url 的字典、元组列表、字节或文件对象。
#*json 参数为要发送到指定 url 的 JSON 对象。
#*args 为其他参数，比如 cookies、headers、verify等。
# 导入 requests 包
import requests

# 发送请求
x = requests.post('https://www.runoob.com/try/ajax/demo_post.php')

# 返回网页内容
print(x.text)

#*post 请求带参数：
#*实例
# 导入 requests 包
import requests

# 表单参数，参数名为 fname 和 lname
myobj = {'fname': 'RUNOOB','lname': 'Boy'}

# 发送请求
x = requests.post('https://www.runoob.com/try/ajax/demo_post2.php', data = myobj)

# 返回网页内容
print(x.text)

# done31:random 模块
# note263:random模块介绍
#*Python random 模块主要用于生成随机数。
#*random 模块实现了各种分布的伪随机数生成器。
#*接下来我们使用 random() 方法返回一个随机数，它在半开放区间 [0,1) 范围内，包含 0 但不包含 1。
#*实例
# 导入 random 包
import random
# 生成随机数
print(random.random())

#*seed() 方法改变随机数生成器的种子，可以在调用其他随机模块函数之前调用此函数。
#*实例
import random

random.seed()
print ("使用默认种子生成随机数：", random.random())
print ("使用默认种子生成随机数：", random.random())

random.seed(10)
print ("使用整数 10 种子生成随机数：", random.random())
random.seed(10)
print ("使用整数 10 种子生成随机数：", random.random())

random.seed("hello",2)
print ("使用字符串种子生成随机数：", random.random())

# note264:random模块方法
方法	                                        描述
seed()	                                       初始化随机数生成器
getstate()	                                   返回捕获生成器当前内部状态的对象。
setstate()	                                   state 应该是从之前调用 getstate() 获得的，并且 setstate() 将生成器的内部状态恢复到 getstate() 被调用时的状态。
getrandbits(k)	                               返回具有 k 个随机比特位的非负 Python 整数。 此方法随 MersenneTwister 生成器一起提供，其他一些生成器也可能将其作为 API 的可选部分提供。 在可能的情况下，getrandbits() 会启用 randrange() 来处理任意大的区间。
randrange()	从 range(start, stop, step)        返回一个随机选择的元素。
randint(a, b)	                               返回随机整数 N 满足 a <= N <= b。
choice(seq)	                                   从非空序列 seq 返回一个随机元素。 如果 seq 为空，则引发 IndexError。
choices(population, weights=None, *, cum_weights=None, k=1)	从 population 中选择替换，返回大小为 k 的元素列表。 如果 population 为空，则引发 IndexError。
shuffle(x[, random])	                       将序列 x 随机打乱位置。
sample(population, k, *, counts=None)	       返回从总体序列或集合中选择的唯一元素的 k 长度列表。 用于无重复的随机抽样。
random()	                                   返回 [0.0, 1.0) 范围内的下一个随机浮点数。
uniform()	                                   返回一个随机浮点数 N ，当 a <= b 时 a <= N <= b ，当 b < a 时 b <= N <= a 。
triangular(low, high, mode)	                   返回一个随机浮点数 N ，使得 low <= N <= high 并在这些边界之间使用指定的 mode 。 low 和 high 边界默认为零和一。 mode 参数默认为边界之间的中点，给出对称分布。
betavariate(alpha, beta)	                   Beta 分布。 参数的条件是 alpha > 0 和 beta > 0。 返回值的范围介于 0 和 1 之间。
expovariate(lambd)	                           指数分布。 lambd 是 1.0 除以所需的平均值，它应该是非零的。
gammavariate()	                               Gamma 分布（ 不是伽马函数） 参数的条件是 alpha > 0 和 beta > 0。
gauss(mu, sigma)	                           正态分布，也称高斯分布。 mu 为平均值，而 sigma 为标准差。 此函数要稍快于下面所定义的 normalvariate() 函数。
lognormvariate(mu, sigma)	                   对数正态分布。 如果你采用这个分布的自然对数，你将得到一个正态分布，平均值为 mu 和标准差为 sigma 。 mu 可以是任何值，sigma 必须大于零。
normalvariate(mu, sigma)	                   正态分布。 mu 是平均值，sigma 是标准差。
vonmisesvariate(mu, kappa)	                   冯·米塞斯分布。 mu 是平均角度，以弧度表示，介于0和 2*pi 之间，kappa 是浓度参数，必须大于或等于零。 如果 kappa 等于零，则该分布在 0 到 2*pi 的范围内减小到均匀的随机角度。
paretovariate(alpha)	                       帕累托分布。 alpha 是形状参数。
weibullvariate(alpha, beta)	                   威布尔分布。 alpha 是比例参数，beta 是形状参数。


